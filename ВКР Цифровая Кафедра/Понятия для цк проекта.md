Корутины – это легковесные потоки в Kotlin для асинхронных операций

- **`suspend`** – означает, что функция может быть приостановлена и возобновлена позже (без блокировки основного потока).
    
- **`.await()`** – ждёт завершения асинхронной задачи (входа через Firebase) и возвращает результат.

### **`Unit` в Kotlin**

- Аналог `void` в Java – означает "ничего не возвращает".


Ключевое слово `override` означает, что метод переопределяет (реализует) абстрактный метод из интерфейса или родительского класса.



## **`LiveData` vs `MutableLiveData`**

```

private val _loginState = MutableLiveData<Result<Unit>>() // Для внутреннего использования
val loginState: LiveData<Result<Unit>> get() = _loginState // Для внешнего доступа

```

|Тип|Изменяемость|Кто может изменять|Где использовать|
|---|---|---|---|
|**`LiveData`**|Неизменяемый|Только для чтения|В UI (Composable/Activity/Fragment).|
|**`MutableLiveData`**|Изменяемый|Может обновляться|Внутри ViewModel.|

## **`viewModelScope.launch`**

Это запуск корутины в специальном `CoroutineScope`, который автоматически отменяется при очистке ViewModel.

**Зачем нужно?**

- Асинхронные операции (сеть, БД) не должны блокировать основной поток.
    
- Гарантия, что корутина не "утечёт" (например, если пользователь ушёл с экрана).


`CoroutineScope` – это "контейнер" для корутин, который управляет их жизненным циклом.  
Все корутины, запущенные внутри этого scope, автоматически отменяются, когда scope уничтожается.


## **Что такое `value?.let { ... }`?**

1. **`value?`** – безопасное обращение (если `value == null`, блок `let` не выполнится).
2.  **`.let { }`** – функция-расширение, которая передаёт текущее значение в лямбду.

## **MVVM**
MVVM (Model-View-ViewModel) — это архитектурный паттерн, который разделяет логику приложения на три компонента:

1. **Model** — данные и бизнес-логика (Room, Firebase, UseCases).
    
2. **View** — UI (Composable-функции в Jetpack Compose).
    
3. **ViewModel** — посредник между Model и View, хранит состояние и обрабатывает действия пользователя.



`StateFlow` — это поток данных (как `LiveData`), который:

- **Хранит текущее состояние** (последнее emitted значение).
    
- **Уведомляет подписчиков** при изменении этого состояния.
    
- **Горячий поток** (начинает emit данные сразу, даже если нет подписчиков).
при новых подписчиках не вызывает выполнение потока заново, как холодный
    

### **`.stateIn(...)`**

Преобразует холодный `Flow` в горячий `StateFlow`, который:

1. Кэширует последнее значение.
    
2. Может быть подписан многократно (без повторного выполнения запроса к БД).

#### **Параметры `stateIn`**:

|Параметр|Значение|Зачем нужен|
|---|---|---|
|**`scope: CoroutineScope`**|`viewModelScope`|Привязывает поток к жизненному циклу ViewModel (автоматическая отмена при очистке).|
|**`started: SharingStarted`**|`SharingStarted.Lazily`|Стратегия запуска потока. `Lazily` — поток стартует при первом подписчике и живёт до отмены `scope`.|
|**`initialValue: T`**|`emptyList()`|Начальное значение, пока поток не emit данные.|



### Что такое `also`?

- Это один из **scope-функций Kotlin** .
- Он позволяет выполнить блок кода **после создания объекта** , передавая его как `it` или с именем (`updatedUser` в данном случае).