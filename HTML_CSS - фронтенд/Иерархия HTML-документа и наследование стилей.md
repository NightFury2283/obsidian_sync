
[[Веб-страницы - язык HTML]]
[[Питон Практикум]]


Анализируя код, браузер интерпретирует вложенность тегов HTML как древовидную структуру, создавая в памяти **DOM-дерево** (от англ. _Document Object Model_ — «объектная модель документа»).

Сравним код страницы и её DOM-дерево:


```html
<!DOCTYPE html>
<html lang="ru">
  <head>
    <title>Дама сдавала багаж | С.Маршак</title>
  </head>
  <body>
    <header>
      <nav id="top-nav">
      <!-- ... -->
      </nav>
    </header>
    <main>
      <p class="negative">
        Дама сдавала багаж:
      </p>
      <!-- ... -->
    </main>
    <footer>
      <!-- ... -->
    </footer>
  </body>
</html>
```


DOM-дерево для такого кода:

```
document 
└── html  
    ├── head  
    │   └── title
    └── body
        ├── header
        │   └── nav
        ├── main 
        │   └── p
        └── footer  
```





- для узлов `header`, `main` и `footer` родительским (_parent_) узлом будет `body`;
- по отношению друг к другу узлы `header`, `main` и `footer` — это «узлы одного уровня», _siblings_;
- узел `p` будет дочерним (_child_) для узла `main`.


## Наследование стилей

Работа CSS зависит от структуры DOM. Например, CSS-правила, присвоенные определённому узлу, могут наследоваться всеми его потомками.

Достаточно применить к `body` правила, устанавливающие размер и цвет шрифта...



```css
body {
  font-size: 40px;
  color: red;
}
```


...и большинство вложенных элементов приобретут те же свойства: любой текст, независимо от тега, в который он заключён, будь то `<h1>`, `<h2>` или `<p>`, будет отображён шрифтом красного цвета и размером в 40 пикселей.


Со свойствами `padding` и `margin` традиционно возникает путаница; разницу между ними проще всего показать на картинке.


![[Pasted image 20250427141003.png]]



У любого элемента (будь то `div`, `p` или `h1`) есть определённые границы.

Свойство `padding` определяет отступ от этих границ до содержимого элемента (например, от границ элемента `h1` до текста, содержащегося в нём).

Свойство `margin` определяет расстояние до следующего элемента.


### Специфичность селекторов и конфликт свойств

К одному элементу можно применить несколько CSS-правил, описанных для разных селекторов. Если в этих правилах описаны одинаковые свойства с разными значениями, то возникнет конфликт:


```html
...
<style>
  .big-text {
    font-size: 100px;
  }
  #very-big-text {
    font-size: 100500px;
  }
</style>
...
<body>
  <h1 id="very-big-text" class="big-text">
    Большой заголовок большой страницы
  </h1>
</body>
```


Для решения таких конфликтов есть понятие **«специфичность селекторов»**.

В общем случае правило такое: чем меньше количество элементов, которые потенциально может выбрать селектор, тем этот селектор **приоритетнее** (специфичнее, весомее).

Селектор по тегу выберет все указанные теги, вне зависимости от того, задан ли им класс или `id`. Селектор по классу может выбрать несколько элементов (ведь в коде может быть несколько тегов с одинаковым значением атрибута `class`). А селектор по идентификатору всегда укажет только на один элемент (ведь `id` в пределах страницы должен быть уникален). Выходит, самый высокий приоритет — у селектора по `id`, а самый низкий — у селектора по тегу.

Можно выделить четыре уровня специфичности селекторов (в порядке повышения приоритета):

- селектор по тегу;
- селектор по классу;
- селектор по ID;
- стиль, описанный _inline_, в атрибуте `style` прямо в HTML-коде.


Может оказаться и так, что к одному элементу применены два селектора с одинаковым приоритетом. В такой ситуации действует правило «какие стили описаны ниже, те и приоритетнее».



