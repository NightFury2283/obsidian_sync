[[Фреймворк Django. Работа с проектами]]
[[Python]]
[[API]]
[[Питон Практикум]]


Для обработки запросов к API могут использоваться представления как в виде **функций**, так и в виде **классов**. Функции, как правило, позволяют лучше понять как работает код; вот с них и начнём.


## View-функции API

Напишем простую view-функцию API с именем `hello()`, которая при GET-запросе будет возвращать вот такой ответ в формате JSON:

```json
{
    "message": "Это был GET-запрос!"
}
```


При POST-запросе эта view-функция будет возвращать JSON, содержащий те же данные, которые были отправлены в запросе: что пришло — то и возвращаем:

```json
{
    "message": "Получены данные",
    "data": {
        <JSON из тела POST-запроса>
    }
}
```


С view-функциями вы знакомы по опыту работы с Django-приложениями; view-функции API в Django REST framework применяются и выглядят сходным образом.

### Декоратор @api_view

Для «настройки» view-функции на работу с API в Django REST framework есть декоратор **@api_view**. В качестве аргумента декоратору передают список типов HTTP-запросов, которые должна обрабатывать эта функция:


```python
@api_view([<разрешённые типы HTTP-запросов>])
def hello(request):
...
```


Ещё одно отличие view-функции API в Django REST framework состоит в том, что они возвращают специальный объект класса **Response**; в этот объект в качестве аргумента передаётся Python-словарь, данные из которого и должны быть отправлены в ответ на запрос в JSON формате.

Опишем API-функцию `hello()`:

```python
from rest_framework.decorators import api_view  # Импортировали декоратор
from rest_framework.response import Response  # Импортировали класс Response

@api_view(['GET', 'POST'])  # Применили декоратор и указали разрешённые методы
def hello(request):
    # По задумке, в ответ на POST-запрос нужно вернуть JSON с теми данными, 
    # которые получены в запросе.
    # Для этого в объект Response() передаём словарь request.data. 
    if request.method == 'POST':
        return Response({'message': 'Получены данные', 'data': request.data})

    # В ответ на GET-запрос нужно вернуть JSON
    # Он тоже будет создан из словаря, переданного в Response()
    return Response({'message': 'Это был GET-запрос!'})
```


Сейчас в декораторе `@api_view` указаны два разрешённых метода — GET и POST. В ответ на запросы других типов view-функция вернёт ответ _“Error 405 Method Not Allowed”_ — это предусмотрено в декораторе @api_view.

В ответ view-функции добавлены ключи `message` и `data`, имена ключей могут быть любыми строками.

View-функция `hello()` достаточно проста — она просто возвращает полученные данные, не обрабатывая и даже не проверяя их: что передали — на том и спасибо.

В реальном мире view-функции обычно сложнее, например они могут создавать новые записи в БД или наоборот: в ответ на запрос возвращать данные, полученные из БД.

На примере view-функции `cat_list()` из проекта **Kittygram** разберёмся, как работает этот механизм.


## View-функция API: обработка POST-запроса с одним объектом

Начнём с создания записи в базе данных об одном котике через API.

Модель **Cat** содержит несколько полей:

- имя котика: `name`,
- его цвет: `color`,
- его год рождения: `birth_year`.

Чтобы добавить в БД запись о новом котике, нужно отправить POST-запрос на эндпоинт `cats/`. В теле POST-запроса должен быть передан объект в формате JSON; содержание этого объекта должно соответствовать модели Cat.

JSON, переданный в POST-запросе, может быть таким:

```python
# Тело POST-запроса
{
    "name": "Стёпа",
    "color": "белый",
    "birth_year": 1971
}
```


Прежде чем сохранить полученные данные в БД, их нужно десериализовать: удостовериться, что они соответствуют ожиданиям модели **Cat** и конвертировать из простых типов данных в объект.

Для этого потребуется сериализатор; он уже описан в проекте, это класс **CatSerializer**.


```python
# kittygram/cats/serializers.py
from rest_framework import serializers

from .models import Cat


class CatSerializer(serializers.ModelSerializer):
    class Meta:
        model = Cat
        # В прошлом уроке fields = '__all__' изменили на:
        fields = ('name', 'color', 'birth_year')
```


Чтобы подключить сериализатор к обработке данных, во view-функции `cat_list()` нужно создать экземпляр класса CatSerializer и передать в него данные из тела POST-запроса.

Данные в запросе приходят в формате JSON, преобразуются в Python-словарь, доступ к которому можно получить через объект `request.data`. Этот словарь и передаётся в сериализатор через именованный параметр `data`.

```python
# kittygram/cats/views.py
from .serializers import CatSerializer

@api_view(['GET', 'POST'])
def cat_list(request):
    # Обработчик для POST-запросов.
    if request.method == 'POST':
        serializer = CatSerializer(data=request.data)

# GET-запросы разрешены в декораторе, но для них нет обработчика, 
# поэтому в ответ на GET-запрос вернётся ошибка 
# 500 Internal Server Error.
# Допишем этот обработчик позже.

```


Теперь данные, полученные в запросе, можно провалидировать.


### Валидация входящих данных

Для валидации полученных данных надо вызвать в объекте сериализатора `serializer` метод `is_valid()`. В зависимости от результатов валидации можно среагировать на запрос по-разному:

- если валидация прошла успешно — сохраним запись в БД при помощи метода `save()` и в качестве подтверждения вернём в ответе созданный объект и статус-код, соответствующий успешному выполнению операции;
- если валидация не пройдена — вернём в ответе объект `serializer.errors`. В этом объекте сериализатор автоматически создаёт словарь с перечнем ошибок, возникших при валидации. Вместе с перечнем ошибок вернём и статус-код, соответствующий неудачному результату выполнения операции.

При разработке Rest API хорошей практикой считается всегда возвращать соответствующий ситуации статус-код ответа.

Если в коде не указать статус ответа — он всё равно будет отправлен автоматически; однако в таком случае может вернуться код, не отражающий реальное состояние дел.

Список возможных кодов и их описание можно посмотреть [здесь, в документации Django REST framework](https://www.django-rest-framework.org/api-guide/status-codes/).


Выбирайте и указывайте любой подходящий к ситуации статус-код; какой бы статус вы не указали — он будет успешно отправлен в ответе. Даже если вместо статуса 200 вы отправите код 404 — ничего не сломается. Но лучше так не шутить: не все клиенты будут рады.

Посмотрите на пример ответа API: первая строка — это [Status-Line](https://httpwg.org/specs/rfc7230.html#status.line), в ней передаётся информация об общем результате запроса. В начале строки — версия протокола, за ней — код и текстовое описание статуса ответа.


![[Pasted image 20250721114002.png]]


В интерфейсе Postman строка Status-Line отображается в общей сводке о запросе:

![[Pasted image 20250721114131.png]]


Добавим в код валидацию данных. Теперь view-функция, которая добавляет в БД новую запись, будет выглядеть так:

```python
@api_view(['GET', 'POST'])
def cat_list(request):
    if request.method == 'POST':
        # Создаём объект сериализатора 
        # и передаём в него данные из POST-запроса
        serializer = CatSerializer(data=request.data)
        if serializer.is_valid():
            # Если полученные данные валидны —
            # сохраняем данные в базу через save().
            serializer.save()
            # Возвращаем JSON со всеми данными нового объекта
            # и статус-код 201
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        # Если данные не прошли валидацию — 
        # возвращаем информацию об ошибках и соответствующий статус-код:
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
```


## View-функция API: обработка POST-запроса со списком объектов

Следующая задача — научить view-функцию принимать и обрабатывать список объектов. Такой подход будет востребован: если владелец котофермы захочет добавить в базу всех своих котов, ему не придётся отправлять сотню отдельных запросов.


POST-запрос на добавление нескольких объектов будет выглядеть иначе, чем в случае с одним объектом: в теле POST-запроса будет передан не объект с полями `name`_,_ `color` и `birth_year`, а **список** таких объектов.

```json
# Пример JSON со списком объектов

[
    {
        "name": "Стёпа",
        "color": "белый",
        "birth_year": 1971
    },
    {
        "name": "Мурка",
        "color": "рыжий",
        "birth_year": 2010
    },
    {
        "name": "Пушок",
        "color": "чёрный",
        "birth_year": 2018
    }
]
```


Чтобы сериализатор был готов принять список объектов, в конструктор сериализатора нужно передать именованный параметр `many=True`.

```python
serializer = CatSerializer(data=request.data, many=True)
```


Запрос со списком объектов будет обработан по тому же принципу, что и запрос с одним объектом.

Если этот параметр не указан, сериализатор не станет обрабатывать список объектов и вернёт ошибку: _"Invalid data. Expected a dictionary, but got list."_

Если в сериализаторе указан параметр `many=True`, а в запросе передан отдельный объект вместо списка объектов — сериализатор вернёт ошибку: _"Expected a list of items but got type dict."_

### Обработка GET-запроса на получение списка объектов


Вернуть список объектов в ответ на соответствующий GET-запрос можно с помощью той же view-функции.

При подготовке ответа view-функция должна получить из базы данных **queryset**, в котором будут храниться запрошенные объекты модели (например, все объекты модели **Cat**).

Затем queryset нужно сериализовать. Для этого queryset передаётся первым аргументом в конструктор сериализатора; вторым аргументом будет `many=True`:

```python
# Получаем все объекты модели
cats = Cat.objects.all()
# Передаём queryset в конструктор сериализатора
serializer = CatSerializer(cats, many=True)
```

В результате view-функция API `cat_list()` примет такой вид:

```python
@api_view(['GET', 'POST'])  # Разрешены только POST- и GET-запросы
def cat_list(request):
    # В случае POST-запроса добавим список записей в БД
    if request.method == 'POST':
        serializer = CatSerializer(data=request.data, many=True)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
    # В случае GET-запроса возвращаем список всех котиков
    cats = Cat.objects.all()
    serializer = CatSerializer(cats, many=True)
    return Response(serializer.data)
```


### Создать vs обновить

В результате вызова метода `save()` сериализатора может быть создана новая запись в БД, а может быть обновлена существующая запись.

Для создания новой записи в сериализатор передаются только данные из запроса; объект будет создан при вызове метода `save()`.


```python
...
serializer = CatSerializer(data=request.data)
# Если вызвать serializer.save(), будет создана новая запись в БД
```


Для обновления существующей записи первым параметром в сериализатор передаётся тот объект модели, который нужно обновить. В этом случае вызов `save()` не приведёт к созданию нового объекта.

```python
...
cat= Cat.objects.get(id=id)
serializer = CatSerializer(cat, data=request.data)
# Если вызвать serializer.save(), будет обновлён существующий экземпляр Cat
```


### Сериализатор и метод PATCH

В проекте Kittygram может возникнуть необходимость обновить существующие записи. Например, котик Анатолий 2018 года рождения был серый, но его перекрасили в рыжий. Надо обновить запись в базе данных, но потребуется заменить значение лишь одного поля, не перезаписывая весь объект целиком.

Предположим, запись об Анатолии хранится в базе данных под id=15. Для частичного обновления данных следует отправить PATCH-запрос на эндпоинт [http://127.0.0.1:8000/cats/15/](http://127.0.0.1:8000/cats/15/); в теле этого запроса будет описание лишь одного поля:

```json
{
  "color": "Рыжий"
}
```


По умолчанию сериализатор ожидает получить значения всех полей, перечисленных в его параметре `fields`. Если же сериализатор получит не все значения — это вызовет ошибку _400 Bad Request "This field is required."_: «в запросе не передано обязательное поле!».

Причиной такой ошибки может стать PATCH-запрос.

Если при создании экземпляра сериализатора указать аргумент `partial=True` — отсутствие в запросе обязательных полей не приведёт к ошибке.

```python
serializer = CatSerializer(cat, data=request.data, partial=True)
```


### Разделение обязанностей между view-функциями API

Классический API для целевой модели — это, как правило, реализация шести операций:

- создание нового объекта;
- получение информации об объекте;
- удаление объекта;
- замещение объекта (целиком);
- изменение одного или нескольких полей объекта;
- получение списка объектов.

Хорошая практика — сгруппировать эти операции в две view-функции.

Первая view-функция добавляет новые объекты в коллекцию или возвращает все объекты коллекции, например:


Вторая view-функция обрабатывает запросы для получения, изменения (полного или частичного) и удаления одиночного объекта:

- GET-запрос к адресу `cats/<pk>/` вернёт информацию о конкретном котике по его id;
- запросы PUT, PATCH или DELETE к тому же адресу перезапишут, изменят или удалят существующую запись о котике.

В результате для всех шести действий в _urls.py_ потребуется описать лишь два эндпоинта:

- `cats/`,
- `cats/<int:pk>/`.
    
    А ссылаться эти эндпоинты будут на две view-функции во _views.py_, например:
    
- `cat_list()`,
- `cat_detail()`.

При работе держите в голове важные детали:

- view-функция обрабатывает только те запросы, которые указаны в декораторе `@api_view([<разрешённые HTTP-методы>])`;
- данные из POST-запроса сохраняются в словаре `request.data` и передаются в конструктор сериализатора через именованный параметр **data**: `data=request.data`;
- вместе с ответом необходимо вернуть клиенту правильный статус-код.

Полная реализация всех методов:

```python
#  импортируйте в код всё необходимое

from rest_framework.decorators import api_view

from rest_framework.response import Response

from rest_framework import status

from .models import Post

from .serializers import PostSerializer

  
  

@api_view(['GET', 'POST'])

def api_posts(request):

    if request.method == 'POST':

        serializer = PostSerializer(data=request.data)

        if serializer.is_valid():

            serializer.save()

            return Response(serializer.data, status=status.HTTP_201_CREATED)

        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

    posts = Post.objects.all()

    serializer = PostSerializer(posts, many=True)

    return Response(serializer.data)

  
  

@api_view(['GET', 'PUT', 'PATCH', 'DELETE'])

def api_posts_detail(request, pk):

    post = Post.objects.get(pk=pk)

    if request.method == 'PUT' or request.method == 'PATCH':

        serializer = PostSerializer(post, data=request.data, partial = True)

        if serializer.is_valid():

            serializer.save()

            return Response(serializer.data)

        return Response(serializer.errors, status = status.HTTP_400_BAD_REQUEST)

    elif request.method == 'DELETE':

        post.delete()

        return Response(status=status.HTTP_204_NO_CONTENT)

    serializer = PostSerializer(post)

    return Response(serializer.data)
```

