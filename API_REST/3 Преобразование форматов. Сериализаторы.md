[[Фреймворк Django. Работа с проектами]]
[[Python]]
[[API]]
[[Питон Практикум]]

### Интерфейс для программ: API

В свою очередь, API — это интерфейс для программ, именно программы будут обмениваться информацией друг с другом, HTML-шаблоны в этой системе не понадобятся.

При этом программы, которые будут обмениваться данными, могут быть написаны на разных языках программирования. Однако благодаря API они без проблем смогут общаться между собой, обмениваясь данными в удобном и едином для всех формате (например — в формате JSON или XML).

Таким образом, чтобы описанное взаимодействие получилось, данные постоянно должны преобразовываться из формата в формат: из типов данных конкретного языка программирования в выбранный формат обмена данными и обратно. Такие преобразования получили названия: **сериализация** и **десериализация**.


В качестве примера взаимодействующих программ можно взять блог-платформу и мобильное приложение, созданное для этого сервиса.

Серверная часть и мобильное приложение будут взаимодействовать через API: приложение отправляет запросы на сервер, к API, передавая или получая данные.

Разработчик API сам выбирает формат, в котором API возвращает данные; установим, что API будет работать с JSON.

### Сериализация

Первая задача: пользователь хочет прочесть какой-то конкретный пост из своей ленты друзей. Для этого должны быть выполнены такие операции:

- Мобильное приложение отправит GET-запрос к API Yatube; в запросе будет передан id поста.
- API сделает запрос к базе данных проекта в надежде получить оттуда экземпляр класса `Post` с заданным id.
- Если пост с таким id есть в БД, то программа получит объект класса Post (этот объект содержит несколько полей разных типов данных).
- В качестве ответа на вопрос нужно вернуть данные в формате JSON. Преобразование Python-объекта в JSON происходит в два шага:
    - сложный объект (например, экземпляр модели) преобразуется в словарь, содержащий простые типы данных Python;
    - получившийся Python-словарь конвертируется («рендерится») в JSON.
- JSON отправляется в HTTP-ответе в мобильное приложение.

Например, из БД получен объект класса Post, который можно было бы описать так:

```python
post = Post(
    id=87,
    author='Робинзон Крузо', 
    text='23 ноября. Закончил работу над лопатой и корытом.',
    pub_date='1659-11-23T18:02:33.123543Z'
)
```


После сериализации этого объекта будет создан такой JSON:

```json
{
    "id": 87,
    "author": "Робинзон Крузо", 
    "text": "23 ноября. Закончил работу над лопатой и корытом.",
    "pub_date": "1659-11-23T18:02:33.123543Z"
}
```


### Валидация и десериализация

Вторая задача: пользователь решил через мобильное приложение добавить в блог новую запись. Пользователь набрал текст и нажал кнопку «Отправить».

Из мобильного приложения будет отправлен POST-запрос к API, и при получении запроса API выполнит действия, подобные описанным, но в обратном направлении: преобразует JSON из запроса в Python-объект. В процесс добавится дополнительный шаг — проверка данных на корректность, **валидация**.

Будут выполнены такие операции:

- Мобильное приложение сформирует и отправит POST-запрос к API проекта; в теле запроса будет передан JSON, содержащий всю необходимую информацию для создания нового поста.
- Полученный JSON должен быть **десериализован**. Десериализация происходит в три этапа:
    - Преобразование JSON в простые типы данных Python.
    - Валидация — проверка соответствия полученных данных ожиданиям.
    - Конвертация валидированных данных в сложные объекты Python (в queryset или объект модели).
- Если полученные данные соответствуют модели, то API отправит запрос к БД, чтобы добавить в неё новый объект, а пользователю отправит ответ с подтверждением

Если же полученные данные не пройдут валидацию, то API не будет добавлять их в базу данных, а просто отправит ответ с сообщением об ошибке.

Пример JSON, который API получит в POST-запросе:


```json
{
    "author": "Робинзон Крузо", 
    "text": "24 декабря. Всю ночь и весь день шёл проливной дождь.",
    "pub_date": "1659-12-24T21:14:56.123543Z"
}
```

JSON будет десериализован в объект Python, который можно описать так:

```python
post = Post(
    author='Робинзон Крузо', 
    text='24 декабря. Всю ночь и весь день шёл проливной дождь.',
    pub_date='1659-12-24T21:14:56.123543Z'
)
```


## Классы-сериализаторы в DRF

В Django REST Framework есть классы, которые способны принимать участие во всех трёх операциях: сериализации, валидации и десериализации. Эти классы называются **сериализаторы (serializers)**.

Сериализаторы преобразуют сложные данные, такие как queryset или экземпляр модели, в простые типы данных Python, которые затем можно конвертировать («отрендерить») в JSON, XML или другие форматы обмена данными.

Сериализаторы выполняют и обратное преобразование: конвертируют данные, полученные из JSON, в сложные объекты; при этом данные проходят валидацию.

Сериализаторы могут работать с моделями Django и с обычными Python-классами.

- Для работы с обычными Python-классами сериализаторы наследуют от класса **Serializer**.
- Сериализаторы, работающие с моделями, наследуют от **ModelSerializer**.

Эти классы чем-то схожи с классами **Form** и **ModelForm**: при получении запроса эти классы валидируют полученные данные и конвертируют их в Python-объекты, а при создании ответа получают на вход Python-объект и преобразуют его в необходимый формат.


Чтобы класс-сериализатор выполнил свою работу, в нём должны быть описаны:

- поля; их названия будут служить ключами в JSON при сериализации; наличие этих полей будет проверяться в JSON при десериализации;
- типы этих полей: чтобы сериализатор мог правильно конвертировать данные, он должен «знать», какие типы данных соответствуют тому или иному полю класса или модели;
- параметры этих полей (например, максимальную и минимальную длину строки для CharField).

## Сериализатор для модели: **ModelSerializer**


Чаще всего работа с данными в Django осуществляется через модели, и в таких случаях сериализатор наследуется от класса [ModelSerializer](https://www.django-rest-framework.org/api-guide/serializers/#modelserializer).

При создании такого сериализатора во внутреннем классе `Meta` нужно указать модель, с которой должен работать сериализатор, и список тех полей модели, которые нужно сериализовать или десериализовать. С внутренним классом `Meta` вы уже встречались при работе с **ModelForm**, в **ModelSerializer** его назначение аналогично.

Для наследников ModelSerializer нет необходимости описывать типы полей и их параметры: сериализатор сам их определит, взяв за основу поля указанной модели.

В качестве примера опишем модель **Comment** и сериализатор для неё:

```python
...

class Comment(models.Model):
    post = models.ForeignKey(Post, on_delete=models.CASCADE)
    author = models.ForeignKey(User, on_delete=models.CASCADE)
    text = models.TextField()
    created = models.DateTimeField('created', auto_now_add=True)

...

class CommentSerializer(serializers.ModelSerializer):
    class Meta:
        model = Comment
        # Указываем поля модели, с которыми будет работать сериализатор;
        # поля модели, не указанные в перечне, сериализатор будет игнорировать.
        # Для перечисления полей можно использовать список или кортеж.
        fields = ('id', 'post', 'author', 'text', 'created')
```


Чтобы сериализатор работал со всеми полями модели без исключения, можно указать `fields = '__all__'`.

Вместо `fields` можно применить настройку **exclude** (англ. «исключить»): в этом случае сериализатор будет работать со всеми полями модели, за исключением перечисленных.

Лучшим решением будет явно перечислять поля. Если в ходе разработки в модель будет добавлено новое поле, не предназначенное для публикации, а в сериализаторе указано `fields = '__all__'` — велик шанс, что содержимое нового поля попадёт в ответ API и будет обнародовано.

«Явное лучше неявного».


### Сериализатор для класса: Serializer

Сериализатор для класса работает аналогично сериализатору для модели. Разница в том, что **ModelSerializer** берёт описание полей из модели, а в классе **Serializer** нужно явным образом описать поля, их типы и параметры.

Для примера создадим Python-класс `Book` и сериализатор для него:


```python
# Класс Book
class Book():
    def __init__(self, author, title, pub_year, genre):
        self.author = author
        self.title = title
        self.pub_year = pub_year
        self.genre = genre

# Создаём сериализатор, наследник предустановленного класса Serializer
class BookSerializer(serializers.Serializer):
    # Описываем поля и их типы
    author = serializers.CharField(max_length=256)
    title = serializers.CharField(max_length=512)
    pub_year = serializers.IntegerField()
    genre = serializers.CharField(64)
```


Поля в сериализаторе обычно называют так же, как и поля того класса, с которым предстоит работать.

По умолчанию сериализатор будет искать в переданном объекте поля с такими же названиями, как и его собственные. Эти же имена послужат ключами в результирующем словаре после сериализации данных.

Если имена полей в сериализаторе и в объекте, переданном в сериализатор, будут различаться — возникнет ошибка `AttributeError`.

Полный перечень типов полей для сериализаторов доступен в [официальной документации](https://www.django-rest-framework.org/api-guide/fields/#boolean-fields).

### Действия разные, но сериализатор один

Один и тот же класс-сериализатор в DRF можно применять как для сериализации, так и для десериализации данных. Логика его работы будет выбрана автоматически, в зависимости от того, какой именно объект передан в сериализатор.


![[Pasted image 20250719214436.png]]


Если в конструктор сериализатора передать экземпляр класса, то будет запущен процесс сериализации. А если в качестве параметра передать данные из JSON-объекта, то будет запущен процесс десериализации.

Код классов-сериализаторов принято выносить в отдельный файл _serializers.py_.

