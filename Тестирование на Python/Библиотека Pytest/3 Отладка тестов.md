[[Python]]
[[Фреймворк Django. Работа с проектами]]
[[Питон Практикум]]

Когда в коде что-то работает не так — в поисках ошибки приходится пошагово отслеживать ход его выполнения. Самый простой и интуитивно понятный способ увидеть, что происходит в программе — в определённых местах кода вывести через `print()` значения переменных или любую другую информацию, которая поможет понять состояние программы в конкретный момент.

Однако в успешно пройденных тестах pytest не выводит в консоль результат выполнения функции `print()`.

Посмотрим, что происходит.

В тестах `test_correct()` и `test_fail()` выведите через `print()` сообщения:

```
# test_example.py
def one_more(x):
    return x + 1


def test_correct():
    print('Правильный тест')  # Новая строка.
    assert one_more(4) == 5


def test_fail():
    print('Неправильный тест')  # Новая строка.
    assert one_more(3) == 5


...  # Остальное содержимое файла. 
```

Запустите эти два теста командой `pytest -k "correct or fail"`.

При запуске тестов pytest выполнил функции `test_correct()` и `test_fail()`; в этих функциях должен был сработать и `print()`.

Но в консоли — не то, что ожидалось:

- не выведена строка «Правильный тест». Казалось бы, эта строка должна была появиться в терминале: ведь функция `test_correct()` была вызвана и выполнена. Но нет.
- в отчёте о тестах появились такие строки:
    
    ```
      --------------------------- Captured stdout call ----------------------------
      Неправильный тест
       
    ```
    
    Это текст из `print()` провалившегося теста, но он выведен в каком-то незнакомом обрамлении.
    

Разберёмся.

Примерный перевод фразы _Captured stdout call_ — это «Захваченный поток вывода»; _stdout_ — это стандартный поток вывода (попросту — данные, которые выводятся в терминал). Pytest перехватывает все данные, которые предназначены для вывода в консоль — и показывает в терминале _stdout_ данные только из провалившихся тестов; остальной поток вывода в консоли не отображается.

При отладке это неудобно, ведь хочется понять, как ведёт себя функция и при успешном прохождении теста, и при его провале.

Перехват потока вывода можно отключить: для этого тесты запускают с ключом `-s` (другой вариант — `--capture=no`). Выполните команду `pytest -s -k "correct or fail"`.

Заработало! В отчёте появился _stdout_ из успешно пройденного теста:

```
test_example.py Правильный тест
.Неправильный тест
F 
```

В консоль выведено название файла с тестами, следом — вывод первого теста; на новой строке — обозначение «тест пройден успешно» (точка) и строка из `print()` второго теста; на третьей строке — обозначение «тест провален» (`F`).

При запуске тестов с ключом `-s` данные из `print()` выводятся независимо от того, успешно прошёл тест или провалился; уже неплохо. Для быстрой отладки пойдёт, но выглядит не очень красиво.

Есть пара вариантов получше. Во-первых, можно запустить тесты с ключом `-v` — вывод расширенного отчёта. Запустите тесты с ключами `-v` и `-s`: `pytest -v -s -k "correct or fail"`.

Выглядит намного лучше:

```
test_example.py::test_correct Правильный тест
PASSED
test_example.py::test_fail Неправильный тест
FAILED 
```

На первой строке — Node ID теста и информация из `print()`, на второй — результат прохождения теста.

Ещё один вариант — вывести дополнительную информацию после всех тестов. Делается это при помощи ключа `-rP`, в котором буква `r` обозначает вывод дополнительной информации (_show extra test summary info_), а заглавная буква `P` указывает на успешно пройденные тесты с выводом данных (_Passed with output_).

Запустите команду `pytest -rP -k "correct or fail"`.

В этом случае отчёт будет таким же, как при выполнении команды pytest, а в конце отчёта появится дополнительный блок:

```
=========================== FAILURES ============================ 
___________________________ test_fail ___________________________ 

<Здесь информация о проваленном тесте>

--------------------- Captured stdout call ---------------------- 
Неправильный тест
============================ PASSES ============================= 
_________________________ test_correct __________________________ 
--------------------- Captured stdout call ---------------------- 
Правильный тест 
```

Если функция `print()` применена в нескольких выполненных тестах, то для каждого из них в этом разделе отчёта будет отдельный блок.

Таким образом, когда нужно вывести в терминал результат работы `print()` из успешно пройденных тестов, используйте любой понравившийся вариант:

1. `pytest -s`
2. `pytest -s -v`
3. `pytest -rP`

## Отладка тестов через Python Debugger

Если вывода через `print()` для отладки тестов и кода недостаточно — можно воспользоваться интерактивной средой отладки **Python Debugger**. Это встроенный в Python отладчик кода, позволяющий отслеживать состояние программы, останавливать выполнение программы в указанном месте, построчно выполнять код, видеть или менять текущее значение переменных.

![](https://pictures.s3.yandex.net/resources/sptint4_picture32x_1683754735.png)

Поработаем с дебаггером на примере функции, которая возвращает количество целых чисел, найденных в переданном списке. К функции есть тест, который передаёт в функцию список с разнородными элементами и проверяет результат работы функции.

Создайте файл _test_pdb.py_ и скопируйте в него этот код:

```
# test_pdb.py
def integers_counter(data):
    # Создаем счётчик для целых чисел.
    integers_found = 0
    # Перебираем в цикле элементы входного списка.
    for item in data:
        # Если элемент - целое число, то увеличиваем счётчик.
        if isinstance(item, int):
            integers_found += 1
    # Возвращаем счётчик.
    return integers_found


def test_counter():
    # Произвольные данные для анализа.
    data = [False, 1.0, "some_string", 3, True, 1, [], False]
    # Вызываем функцию:
    integers = integers_counter(data)
    # Целых чисел должно быть 2.
    assert integers == 2 
```

Выполните тест.

Тест провален с таким выводом:

```
    def test_counter():
        data = [False, 1.0, "some_string", 3, True, 1, [], False]
        integers = integers_counter(data)
>       assert integers == 2
E       assert 5 == 2 
```

Как так, откуда взялось 5? В исходном списке вообще только 3 числа, и одно из них — дробное; в списке только 2 целых числа, тест ожидал получить двойку.

Будем искать причину ошибки через дебаггер.

Первым делом надо войти в режим отладки; при работе с pytest это можно сделать несколькими способами:

1. Запустить тесты с ключом `--pdb`. При таком вызове pdb будет останавливать работу кода на строках, непосредственно спровоцировавших ошибку. Выполнение файла _test_pdb.py_ остановится на строке с `assert`, но такое поведение дебаггера ничем не поможет в поиске ошибки.
2. Запустить тесты с ключом `--trace`. При таком варианте pdb будет вызываться в начале каждого теста. Запускать в этом режиме успешные тесты не имеет смысла, поэтому лучше комбинировать `--trace` с другими ключами, например `pytest --trace --lf -x`. При такой комбинации ключей в режиме дебаггера будет запущен первый упавший тест, и после окончания теста выполнение будет остановлено.
3. Можно установить точку останова (_breakpoint_) непосредственно в коде теста. Для этого требуется импортировать модуль pdb и перед нужной строкой поставить инструкцию: `pdb.set_trace()`. А можно вызвать [встроенную функцию `breakpoint()`](https://docs.python.org/3/library/functions.html#breakpoint), которая по умолчанию вызывает `pdb.set_trace()` (но также может быть переопределена на другой отладчик). При вызове `breakpoint()` импортировать pdb не нужно.

Воспользуемся третьим вариантом. Дополните код следующими строками:

```
# test_pdb.py
# Импортируйте модуль pdb.
import pdb


def integers_counter(data):
    ...  # Содержимое функции.


def test_counter():
    data = [False, 1.0, "some_string", 3, True, 1, [], False]
    pdb.set_trace()  # Точка останова. Именно отсюда начнём дебаг.
    integers = integers_counter(data)
    assert integers == 2 
```

Breakpoint установлен непосредственно перед кодом, в котором могла притаиться ошибка.

Запускайте pytest: начинаем охоту. Никакие ключи при запуске не нужны.

Выполнение программы остановилось на нужной строке:

```
>>>>>>>>>>>>>> PDB set_trace (IO-capturing turned off) >>>>>>>>>>>>>>>>
> <путь до проекта>\test_pdb.py(15)test_counter()
-> integers = integers_counter(data)
(Pdb) 
```

В той же строке, где выведен путь до файла, в скобках указан номер строки, на которой сейчас находится отладчик; дальше идёт название функции, которая сейчас выполняется. Дальнейшая работа будет заключаться в пошаговом выполнении программы: это поможет разобраться в происходящем.

В работе пригодятся команды Python Debugger (значение в скобках — это полная версия команды):

- `n` (`next`) — перейти к следующей строке текущей функции (если в текущей строке вызывается какая-то функция, то pdb не будет «проваливаться» в неё).
- `s` (`step`) — перейти к следующей строке в текущей или в вызываемой функции.
- `j` (`jump`) — перейти к указанному номеру строки. По коду можно передвигаться как вперёд, так и назад; есть ряд ограничений, рассмотрим их позже.
- `c` (`continue`) — продолжить выполнение до следующей точки остановки.
- `p` (`print`) — напечатать значение переменной или выражения.
- `a` (`args`) — напечатать аргументы текущей функции.
- `l` (`list`) — вывести строки кода выполняемой программы.
- `q` (`quit`) — выйти из режима отладки.

Введите в терминал команду `l` или полный вариант `list`.

```
(Pdb) l
 10  
 11
 12     def test_counter():
 13         data = [False, 1.0, "some_string", 3, True, 1, [], False]
 14         pdb.set_trace()  # Точка останова. Именно отсюда начнём дебаг.
 15  ->     integers = integers_counter(data)
 16         assert integers == 2
[EOF] 
```

В консоль будет выведен код, который окружает ту строку, на которой остановился дебаггер.

Если сейчас выполнить команду `n`, то выполнение программы перейдёт **к следующей строке** текущей функции:

```
(Pdb) n
> <путь до проекта>\test_pdb.py(16)test_counter()
-> assert integers == 2 
```

По команде `next` дебаггер просто перешёл к следующей строке кода. Это не то, что требовалось: нужно отследить выполнение функции `integers_counter()`.

Придётся возвращаться назад: применим команду `jump` и укажем номер строки, на которую надо перейти: `jump 15` (или `j 15`, так будет короче).

Если у вас другая нумерация строк — подставьте своё значение: нужно вернуться на строку `integers = integers_counter(data)`:

```
(Pdb) j 15
> <путь до проекта>\test_pdb.py(15)test_counter()
-> integers = integers_counter(data) 
```

Чтобы «провалиться» внутрь вызываемой функции `integers_counter()` — находясь на 15-й строке выполните команду `s` или `step`.

```
> <путь до проекта>\test_pdb.py(15)test_counter()
-> integers = integers_counter(data)
(Pdb) s
--Call--
> <путь до проекта>\test_pdb.py(4)integers_counter()
-> def integers_counter(data): 
```

По команде -s дебаггер последовал за логикой выполнения программы и переключился на строку 4, туда, где объявлена функция `integers_counter()`.

Хочется сразу перейти к выполнению цикла в функции, но со строки, на которую pdb переключился после вызова функции, нельзя никуда прыгнуть с помощью `jump`; pdb выдаст ошибку:

```
(Pdb) j 7
*** Jump failed: can't jump from the 'call' trace event of a new frame 
```

Переместимся небольшими шагами — применим команду `s` или `n`.

```
(Pdb) s
> <путь до проекта>\test_pdb.py(5)integers_counter()
-> integers_found = 0 
```

Отсюда уже можно «прыгать», но не на все строки: например, запрыгнуть сразу внутрь цикла нельзя; у `jump` есть свои ограничения.

```
(Pdb) j 7
*** Jump failed: can't jump into the body of a for loop 
```

С помощью команд `n` или `s` дойдите до строки, которая проверяет тип данных переменной `item`.

```
(Pdb) s
> <путь до проекта>\test_pdb.py(7)integers_counter()
-> if isinstance(item, int): 
```

Распечатаем содержимое переменной `item` при помощи команды `p` (в скобках после этой команды нужно указать, что требуется распечатать).

```
(Pdb) p(item)
False 
```

Всё правильно — первый элемент нашего списка `data` именно такой. Делаем следующий шаг в выполнении программы: команда `s`.

```
(Pdb) s
> <путь до проекта>\test_pdb.py(8)integers_counter()
-> integers_found += 1 
```

А вот это уже неожиданно: программа посчитала `False` целым числом!

Прямо здесь проверим, а действительно ли `False` — это целое число?

```
(Pdb) p(isinstance(False, int))
True 
```

Да, всё верно: Python считает, что `False` — число.

Выполним ещё одну проверку: применим функцию `issubclass()`, которая показывает, является ли определённый класс подклассом другого класса. Проверим, не являются ли булевы значения на самом деле целыми числами.

```
(Pdb) p(issubclass(bool, int))
True 
```

Да, булевы значения — это подкласс целых чисел. Исторически сложилось так, что во второй версии Python не было булевых значений, а вместо `True` и `False` использовали 1 и 0. Потом добавили класс булевых значений, но для обратной совместимости их сделали подклассом `int`, чтобы они вели себя одинаково.

Подробнее об этом можно почитать, например, [на StackOverflow](https://stackoverflow.com/questions/8169001/why-is-bool-a-subclass-of-int/8169049#8169049).

Причина ошибок в подсчётах найдена; осталось немного скорректировать функцию `integers_counter()` — добавить проверку элементов на булевы значения.

Исправленный вариант функции:

```
def integers_counter(data):
    integers_found = 0
    for item in data:
        if not isinstance(item, bool) and isinstance(item, int):
            integers_found += 1
    return integers_found


def test_counter():
    data = [False, 1.0, "some_string", 3, True, 1, [], False]
    integers = integers_counter(data)
    assert integers == 2 
```

Теперь всё будет работать, как задумано.

Попался, баг!

## На заметку

- Чтобы увидеть в терминале информацию из `print()` в успешно пройденных тестах — можно применить ключ `-rP`. Но у ключа `-r` есть и другие варианты, их можно найти [в документации](https://docs.pytest.org/en/7.1.x/how-to/output.html#producing-a-detailed-summary-report) или в справке прямо в терминале: для этого нужно выполнить команду `pytest -h` или `pytest --help`.  
    Справочный блок в терминале довольно большой, но он разбит по тематическим блокам, так что найти нужный фрагмент не будет сложной задачей.
- В любой непонятной ситуации запускайте дебаггер и читайте [документацию](https://docs.python.org/3/library/pdb.html)!

## Самостоятельное задание

Скопируйте в _test_pdb.py_ код из листинга:

```
# test_pdb.py
def transform_list(x):
    x.append(1)
    x.extend([2, 3])
    return x


def test_list():
    a = []
    a = transform_list(a)
    a = [4] + a
    assert a == [1, 2, 3, 4] 
```

Выполните для этого файла все три способа запуска отладки тестов:

1. `pytest --pdb`
2. `pytest --trace`
3. Установите _breakpoint_ через `pdb.set_trace()` и «погуляйте» по программе.

