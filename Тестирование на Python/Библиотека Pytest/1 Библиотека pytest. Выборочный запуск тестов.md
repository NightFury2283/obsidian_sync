[[Python]]
[[Фреймворк Django. Работа с проектами]]
[[Питон Практикум]]

Переходим ко второй популярной библиотеке для тестирования Python-приложений. Встречайте: **pytest**!

Особенности библиотеки pytest:

- Для проверки утверждений применяется ключевое слово `assert`, нет необходимости запоминать дополнительный синтаксис, как в случае с unittest.
- Тесты можно писать в функциях, а можно группировать функции в классы.
- Мощная система фикстур.
- Возможность писать собственные плагины и подключать готовые (например, **pytest-xdist** для параллельного выполнения тестов или **pytest-django** для упрощения работы с Django).
- Возможность запуска тестов для unittest без каких-либо изменений.

Для библиотеки pytest написана качественная [документация](https://docs.pytest.org/en/7.1.x/) с подробными гайдами по основным случаям применения. Так что в любой непонятной ситуации ищите ответ в документации.

## Установка и запуск

Для практической работы с pytest создайте директорию _pytest_trial/_: в ней вы развернёте проект для работы с pytest. Установите и активируйте виртуальное окружение. Через менеджер пакетов pip установите библиотеку pytest:

```
pip install pytest==7.1.2 
```

Начинаем эксперименты: в директории _pytest_trial/_ создайте файл _test_example.py_ и скопируйте в него код из листинга.

В коде — функция и два теста, проверяющие её: один корректный, а другой — заведомо неправильный:

```
# test_example.py
def one_more(x):
    return x + 1


def test_correct():
    assert one_more(4) == 5


def test_fail():
    assert one_more(3) == 5 
```

При запуске тестов pytest ищет в текущей и вложенных директориях все файлы, названия которых начинаются с `test_` или заканчиваются на `_test.py`.

В найденных файлах будут вызваны

- функции, названия которых начинаются с `test` (подчёркивание необязательно);
- методы классов, названия которых начинаются с `Test`:
    - класс не должен содержать метод `__init__`;
    - будут вызваны только те методы, названия которых начинаются с `test` (подчёркивание необязательно).

Всё это — правила обнаружения тестов по умолчанию; при желании их можно изменить.

В Python-проекте есть только один файл с тестами: _my_supertest.py_; в этом файле — только один тест: функция `test_yandex()`. В проекте установлена библиотека pytest, все настройки библиотеки — по умолчанию.

```
# my_supertest.py
def test_yandex():
    assert 1 
```

Какой будет результат запуска команды `pytest`?

Ничего не произойдёт, никакого вывода не будет.

Тоже правильный ответ

Pytest запустится, но не найдет ни одного теста.

Неправильный ответ

Тест пройдет успешно.

Тест прошёл бы успешно, если бы имя файла начиналось бы на “test_” или заканчивалось бы на “_test”. Но имя составлено иначе, и pytest на этот файл даже не посмотрит.

Тест провалится.

Как вам задача?

В консоли перейдите в директорию _pytest_trial/_ и выполните команду для запуска тестов:

```
pytest 
```

При запуске будут выполнены все обнаруженные тесты, от первого до последнего, даже если часть из них упадёт. Остановить выполнение тестов можно сочетанием клавиш Ctrl+C

В консоль будет выведен примерно такой отчёт:

```
========================== test session starts ==================================
platform win32 -- Python 3.9.13, pytest-7.1.2, pluggy-1.0.0
rootdir: <путь до вашего проекта>
collected 2 items

test_example.py .F                                                         [100%]

================================ FAILURES ======================================= 
________________________________ test_fail ______________________________________ 

    def test_answer():
>       assert one_more(3) == 5
E       assert 4 == 5
E        +  where 4 = one_more(3)

test_example.py:10: AssertionError
======================== short test summary info =============================== 
FAILED test_example.py::test_fail - assert 4 == 5
============================ 1 failed in 0.10s ================================= 
```

В строке `test_example.py .F` зелёной точкой обозначаются прошедшие тесты, красной буквой F — проваленные. Ниже идёт информация об ошибках в конкретных тестах.

![](https://pictures.s3.yandex.net/resources/S05_07_1687357324.png)

### Ожидаемое падение: тестируем исключения

В определённых ситуациях функция должна выбрасывать исключение, и это поведение тоже нужно тестировать. Для проверки, что исключение действительно вызывается, применяют контекстный менеджер и функцию `pytest.raises()`; в аргумент функции передаётся тип ожидаемой ошибки (или нескольких возможных ошибок):

```
import pytest


def division(dividend, divisor):
    return dividend / divisor


def test_zero_division():
    with pytest.raises(ZeroDivisionError):  # Ожидается ошибка деления на 0.
        # При вызове функции с такими аргументами возникнет ошибка.
        result = division(1, 0) 
```

Тест будет считаться пройденным, если ожидаемое исключение будет действительно выброшено; если исключения не возникнет или возникнет исключение другого типа — тест считается проваленным.

Функция-валидатор `age_validator()` обрабатывает значение возраста в строковом виде. Она проверяет, что все символы в строке являются цифрами и есть как минимум один символ. Если это так, то возвращается значение, преобразованное в целое число, если нет — функция выбрасывает ошибку.

```
def age_validator(age):
    if not age.isdigit():
        raise ValueError('Возраст должен указываться числом')
    return int(age) 
```

Как надо написать тест, проверяющий вызов функции `age_validator()` с аргументом `'сто лет в обед'`?

Правильный ответ

Использовать контекстный менеджер с указанием типа ошибки `with pytest.raises(ValueError)`

Абсолютно верно. Когда ожидается ошибка конкретного типа — документация рекомендует применять контекстный менеджер `with pytest.raises()` с указанием типа ошибки.

Написать `assert age_validator('сто лет в обед') is ValueError`

Использовать контекстный менеджер `with pytest.raises()`, тип ошибки указывать необязательно.

Как вам задача?

## Подробный (verbosity) и краткий вывод результатов

Если запустить pytest с ключом `-v`, то информация о каждой тестирующей функции будет выведена отдельной строкой. У этого ключа есть и полная форма — `--verbose` (англ. «подробно», «многословно»).

```
test_example.py::test_correct PASSED                                      [ 50%] 
test_example.py::test_fail FAILED                                         [100%] 
```

При запуске тестов с ключом `-v` сообщения об ошибках будут выведены более подробно. Например, в расширенном отчёте о тестах при проверке коллекций pytest укажет на конкретные отличия между реальным и ожидаемым результатом.

Добавьте в файл _test_example.py_ функцию `get_sort_list()` — предполагается, что она будет преобразовывать строку в сортированный список; однако разработчик, который писал эту функцию, наделал ошибок.

В конец файла добавьте тест, проверяющий работу этой функции. В тесте ожидается сортированный список, как и задумано

```
# test_example.py
...
def get_sort_list(string):
    new_list = string.split(',')
    return new_list

...

def test_sort():
    """Тестируем функцию get_sort_list()."""
    result = get_sort_list('Яша, Саша, Маша, Даша')
    assert result == ['Даша', 'Миша', 'Саша', 'Яша'] 
```

Запустите тесты, для начала — командой `pytest`, без ключей. Посмотрим на фрагмент отчёта о тесте `test_sort()`:

```
...
_________ test_sort _______

def test_sort():
        """Тестируем функцию get_sort_list()."""
        ...
E       AssertionError: assert ['Яша', ' Саш...иша', ' Даша'] == ['Даша', 'Маш...'Саша', 'Яша']
E         At index 0 diff: 'Яша' != 'Даша'
E         Use -v to get more diff
... 
```

В отчёте есть рекомендация: «примените ключ `-v`, чтобы увидеть больше различий» — речь о различиях между реальным и ожидаемым результатом.

Последуем этому совету. Запустите тесты с ключом `-v`: `pytest -v`.

Отчёт стал интереснее и понятнее: в нём, в частности, появился блок `Full diff`, детально демонстрирующий отличия реального и ожидаемого результатов:

```
...
_______ test_sort __________

def test_sort():
        """Тестируем функцию get_sort_list()."""
        ...
E       AssertionError: assert ['Яша', ' Саш...иша', ' Даша'] == ['Даша', 'Маш...'Саша', 'Яша']
E         At index 0 diff: 'Яша' != 'Даша'
E         Full diff:
E         - ['Даша', 'Маша', 'Саша', 'Яша']
E         + ['Яша', ' Саша', ' Миша', ' Даша']
... 
```

Вот теперь ясно: автор функции забыл про сортировку. Исправим функцию `get_sort_list()`: отсортируем список.

```
def get_sort_list(string):
    new_list = sorted(string.split(','))  # Сортируем список.
    return new_list 
```

Вновь запустим тесты с ключом `-v`:

```
...
_______ test_sort __________

def test_sort():
        """Тестируем функцию get_sort_list()."""
        result = get_sort_list('Яша, Саша, Миша, Даша')
>       assert result == ['Даша', 'Маша', 'Саша', 'Яша']
E       AssertionError: assert [' Даша', ' М... Саша', 'Яша'] == ['Даша', 'Маш...'Саша', 'Яша']
E         At index 0 diff: ' Даша' != 'Даша'
E         Full diff:
E         - ['Даша', 'Маша', 'Саша', 'Яша']
E         ?            ^
E         + [' Даша', ' Миша', ' Саша', 'Яша']
E         ?   +        + ^      +
... 
```

Список отсортирован, но теперь видны другие ошибки; pytest отмечает отличия в сравниваемых строках:

- `+` — в одной из сравниваемых строк найден дополнительный символ в строке: пробел;
- `^` — отличающийся символ: `а` вместо `и`.

После таких указаний найти ошибки несложно:

- в списке, который вернула функция `get_sort_list()`, найдены лишние пробелы. Это ошибка в применении метода `split()` — в аргументе должна быть не запятая, а запятая с пробелом;
- ожидали элемент со строкой `'Маша'`, а функция вернула `'Миша'`. Это ошибка автора теста: строка в аргументе `get_sort_list()` не соответствует ожидаемому содержимому списка. Похоже на опечатку, надо исправить.

В итоге функция и тест должны выглядеть так:

```
# test_example.py
...
def get_sort_list(string):
    # Сортировка и пробел после запятой в аргументе.
    new_list = sorted(string.split(', '))  
    return new_list

...

def test_sort():
    """Тестируем функцию get_sort_list()."""
    result = get_sort_list('Яша, Саша, Маша, Даша')
    assert result  == ['Даша', 'Маша', 'Саша', 'Яша']  # 'Маша', а не 'Миша'. 
```

Если в отчёте слишком много различий — часть информации скрывается и показывается строка с предложением применить ключ `-vv`:

```
E ...Full output truncated (3 lines hidden), use '-vv' to show 
```

Запуск тестов с ключом `-vv` делает отчёт ещё подробнее и позволяет увидеть все отличия, без сокращений.

Можно запустить pytest с ключом, в котором будет и три, и четыре `v` , но это не даст результата: pytest не поддерживает более подробный вывод; но такие ключи могут использоваться дополнительными плагинами pytest.

В pytest есть и противоположный по назначению ключ: `-q` (полная форма `--quiet` — «тихо»). При запуске тестов с этим ключом детализация отчёта уменьшится; например, будет скрыт этот фрагмент служебной информации:

```
======================= test session starts =========================
platform win32 -- Python 3.9.13, pytest-7.1.2, pluggy-1.0.0
rootdir: <путь до вашего проекта>
collected 2 items 
```

Применение двойного ключа, `-qq`, уберёт сводку о количестве выполненных тестов и о времени их выполнения.

## Выборочный запуск тестов

В проекте могут быть десятки и сотни тестов, и их выполнение может занять заметное время; но нет смысла выполнять их все, когда нужно протестировать лишь небольшой фрагмент программы. В pytest предусмотрена возможность выборочного запуска тестов: можно выполнить отдельный файл с тестами, запустить тесты отдельного класса или отдельный тестовый метод.

Для выборочного запуска в pytest применяется такой синтаксис:

```
pytest file_name.py::TestClassName::test_method_name 
```

С помощью такого синтаксиса описывается, в какой файл должен заглянуть pytest и в каком классе следует искать тот метод, который надо запустить. В этой адресации применяются **Node ID** — идентификаторы, которые pytest присваивает всем тестам.

Слово “node” часто встречается в компьютерной терминологии, дословно оно переводится как «узел» или «точка пересечения линий». Такие «узлы» в приведённом примере — это имя файла, имя класса и имя метода.

Чтобы выполнить все тесты из отдельного файла — обращаемся к нему по имени файла:

```
pytest file_name.py 
```

По Node ID `file_name.py::TestClassName` запустятся все тесты из класса `TestClassName` в файле _file_name.py_:

```
pytest file_name.py::TestClassName 
```

Если тесты представлены функциями, а не классами, то можно запускать отдельные тесты следующим образом:

```
pytest test_example.py::test_fail 
```

Можно запустить сразу несколько тестов, перечислив их Node ID через пробел:

```
pytest test_example.py::test_fail test_example.py::test_correct 
```

Если в проекте есть несколько директорий с тестами — можно запустить тесты в любой из них (или в нескольких, указав их через пробел):

```
pytest pytest_trial 
```

Если тесты находятся в разных директориях, то в Node ID нужно указать имя директории, где лежит тест.

```
pytest pytest_trial/test_example.py 
```

Названия файлов в разных директориях могут повторяться; чтобы избежать конфликтов имён — в каждой директории с тестами должен быть файл `__init__.py`.

При запуске тестов можно не указывать Node ID теста, а применить ключ `-k`: он позволяет запускать тесты по частичному совпадению имени файла, имени класса или тестирующей функции:

```
pytest -k "correct" 
```

По этой команде будут запущены те тесты, в Node ID которых есть слово “correct” — например, тесты с именами `test_correct()`, `testcorrect()` и `test_not_correct()`.

Ключ `-k` можно применить иначе: в параметре этого ключа можно указать, какие тесты не должны запускаться. Для этого применяется ключевое слово `not`.

```
pytest -k "not correct" 
```

Выполните эту команду в директории _pytest_trial/_ и посмотрите, какие тесты будут выполнены.

Помимо `not` для работы с ключом `-k` можно использовать и конструкции с ключевыми словами `and` и `or`; можно применять скобки:

```
pytest -k "(django or python) and not javascript" 
```

При выполнении такой команды будут запущены все тесты, в Node ID которых есть слова “django” или “python”, но при этом не будет слова “javascript”.

В Python-проекте есть только один файл с тестами; в прошлом квизе файл не запустился — и его переименовали в _test_super.py_. Содержимое файла теперь такое:

```
# test_super.py
def test_yandex():
    assert True


def test_google():
    assert False


def test_google_or_yandex():
    assert 'google' == 'yandex' 
```

В проекте установлена библиотека pytest, все настройки библиотеки — по умолчанию.

Сколько тестов запустится при выполнении команды `pytest test_super.py:test_google`?

Правильный ответ

Ни одного

Правильно! В приведённой команде стоит одно двоеточие, а в Node ID двоеточия должны быть двойные. Pytest не найдёт ни одного теста.

Один

Два

Все

Как вам задача?

В Python-проекте есть только один файл с тестами: _test_super.py_. В проекте установлена библиотека pytest, все настройки библиотеки — по умолчанию. Файл с тестами теперь такой

```
# test_super.py
def test_java():
    assert "2" + "2" + "2" == "222"


def test_javascript():
    assert "2" + "2" - "2" == 20


def test_python():
    assert 2 + 2 - 2 == 2 
```
