[[Python]]
[[Фреймворк Django. Работа с проектами]]
[[Питон Практикум]]

Для гибкой настройки и запуска тестов в pytest применяется система **маркеров** — декораторов, которыми можно обернуть тестовые функции, методы, классы или даже целые модули.

Маркеры-декораторы выглядят так: `@pytest.mark.<название маркера>`.

С помощью маркера можно пропустить тест (`skip`) или определить условия, при которых тест должен быть пропущен (`skipif`); можно обозначить тест как ожидаемо упавший (`xfail`). Маркеры можно применять и для управления фикстурами (`usefixtures`).

Чтобы увидеть полный список доступных маркеров — выполните команду

```
pytest --markers 
```

## Пропуск теста

Представьте, что какой-то из тестов обращается к внешнему сервису, а он, как назло, сломался — запросы подвисают, ответы не приходят; тест ждёт ответа, потом происходит разрыв соединения по тайм-ауту. В результате каждое выполнение тестов растягивается, время уходит зря. Сервис, наверно, скоро починят, но работать-то нужно уже сейчас. Можно временно удалить или закомментировать тест, но гораздо лучше поставить маркер пропуска теста.

Пропущенные тесты будут отображаться в общей сводке тестов; отключенный тест будет постояно напоминать о себе; а вот при удалении или комментировании тестов о них можно случайно забыть.

```
import pytest  # Для использования маркеров нужно импортировать модуль pytest.


@pytest.mark.skip  # Тест с этим маркером будет пропущен.
def test_will_be_skipped():
    assert True


def test_will_be_launched():
    assert False 
```

После выполнения тестов в отчёте появится строка с информацией «один тест пропущен, другой провален»:

```
...
sF
... 
```

Можно отметить маркером весь модуль; для этого используется глобальная переменная с зарезервированным наименованием `pytestmark`:

```
import pytest

pytestmark = pytest.mark.skip  # Все тесты в этом файле будут пропущены.


def test_will_be_skipped():
    assert True


def test_also_will_be_skipped():
    assert True 
```

В аргументах маркера `skip` можно указать причину, по которой тест пропущен; это поможет другим разработчикам, да и автору теста будет легче вспомнить, зачем он отключил тест. Строку с описанием причины передают в именованный аргумент `reason`.

К одному тесту можно применить несколько маркеров, поставив нужные декораторы один над другим; для модуля можно перечислить нужные маркеры в списке.

## Маркеры на практике

Модифицируйте файл _test_example.py_:

```
# test_example.py
import pytest


def one_more(x):
    return x + 1


def get_sort_list(str):
    new_list = sorted(str.split(', '))
    return new_list


def test_correct():
    assert one_more(4) == 5


@pytest.mark.skip(reason='Что-то не работает')  # Маркер.
def test_fail():
    assert one_more(3) == 5


def test_sort():
    """Тестируем функцию get_sort_list()."""    
    result = get_sort_list('Яша, Саша, Маша, Даша')
    assert result == ['Даша', 'Маша', 'Саша', 'Яша']


def test_type():
    """Тестируем тип данных, возвращаемых из get_sort_list()."""
    # Провальный тест:
    # ожидаем число, но вернётся список.
    result = get_sort_list('Яша, Саша, Маша, Даша')
    assert isinstance(result, int) 
```

Выполните тесты из этого файла сначала в обычном режиме, а потом в режиме `--verbose` (`-v`).

В формате обычного вывода у вас должны были появиться следующие строки:

```
test_example.py .s.F
...
===================== 1 failed, 2 passed, 1 skipped in 0.12s ====================== 
```

Жёлтая буква `s` обозначает пропущенный (_skipped_) тест. В расширенном отчёте будет отображена причина, по которой пропущен тест:

```
test_example.py::test_correct PASSED                                         [ 25%] 
test_example.py::test_fail SKIPPED (Что-то не работает)                      [ 50%] 
test_example.py::test_sort PASSED                                            [ 75%]
test_example.py::test_type FAILED                                            [100%]
...
===================== 1 failed, 2 passed, 1 skipped in 0.14s ====================== 
```

Информация о количестве пропущенных тестов отображается и в сводке по тестам.

Кроме безусловного пропуска тестов при помощи маркера skip, возможен и пропуск тестов по условию (маркер skipif). Например, этот маркер применяют, когда тесты по-разному выполняются на разных операционных системах или на различных версиях Python.

```
import pytest

old_version = True


@pytest.mark.skipif(
    "sys.version_info > (2, 7)",
    reason='Только для старых версий Python'
)
def test_for_old_versions():
    assert old_version == True
 
```

Подробнее о применении маркера `skipif` можно прочесть [в документации](https://docs.pytest.org/en/stable/how-to/skipping.html#id1).

## Маркер «падающих» тестов

Иногда требуется временно обозначить какой-то тест как «ожидаемо падающий». Например, в коде появился баг, который пока что не удаётся устранить; один из тестов начал падать. Или же разрабатывается/переделывается какой-то функционал, он ещё не готов, а тесты уже написаны — и ясно, что некоторое время они должны падать.

В таких случаях применяют декоратор `@pytest.mark.xfail`:

```
import pytest


@pytest.mark.xfail(reason='Пусть пока падает, завтра починю.')
def test_false():
    assert False 
```

XFail расшифровывается как _eXpected Fail_ — ожидаемый провал теста. Причину падения теста можно указать в именованном аргументе `reason`; это необязательный аргумент.

В отличие от маркера пропуска теста, в тестах с маркером `xfail` выполняются все проверки; более того: если вдруг тест с маркером `xfail` не упал — это будет ошибкой.

Запустите пример из листинга выше: в стандартном выводе вместо точки (обозначающей пройденный тест) появится буква `x`, а в подробном отчёте — сообщение `XFAIL`.

В аргументах маркера `xfail` можно указать условие, при котором ожидается провал теста:

```
@pytest.mark.xfail("sys.version_info < (2, 1)", 
                   reason='Это старая версия Python, чего же вы ждали!')
def test_for_new_python():
    # Тест, который провалится на старых версиях Python.
    ... 
```

Дополнительные примеры есть и [в документации](https://docs.pytest.org/en/stable/how-to/skipping.html#condition-parameter).

## Параметризация тестов

Как и в unittest, в библиотеке pytest есть возможность запускать один тест с разными параметрами. В unittest для этого применяется метод `subTest()`, а в pytest есть декоратор `@pytest.mark.parametrize`, в аргументы которого передаются данные для теста. Этот декоратор можно использовать для многократного запуска теста, класса или модуля с разными параметрами.

У декоратора `@pytest.mark.parametrize` есть два обязательных параметра — названия аргументов и их значения. Тестирующая функция обязательно должна принимать те же параметры, которые объявлены в декораторе.

В файле _test_example.py_ тестирующие функции `test_correct()` и `test_fail()` вызывают функцию `one_more()` с разными аргументами; можно объединить два теста в один и параметризировать его.

Удалите из файла _test_example.py_ тесты `test_correct()` и `test_fail()` и добавьте вместо них тестирующую функцию `test_one_more()` с маркером `parametrize`.

Файл должен принять такой вид:

```
# test_example.py
import pytest 


def one_more(x):
    return x + 1


@pytest.mark.parametrize(
    'input_arg, expected_result',  # Названия аргументов, передаваемых в тест.
    [(4, 5), (3, 5)]  # Список кортежей со значениями аргументов.
)
def test_one_more(input_arg, expected_result):  # Те же параметры, что и в декораторе.
    assert one_more(input_arg) == expected_result


...  # Остальное содержимое файла. 
```

Первый параметр декоратора `@pytest.mark.parametrize` — перечень названий аргументов, которые будут переданы в тестирующую функцию. Эти названия придумывает разработчик; обычно этот перечень пишут в одной строке через запятую или запятую с пробелом; можно передать названия аргументов в списке или в кортеже:

```
...
@pytest.mark.parametrize(
    ['input_arg', 'expected_result'],  # Названия аргументов можно передать списком.
    [(4, 5), (3, 5)]
)
def test_one_more(input_arg, expected_result):
    ... 
```

Второй параметр декоратора `@pytest.mark.parametrize` — набор значений аргументов. Обычно значения передают в виде списка кортежей, но возможны и другие варианты: кортеж кортежей, кортеж списков и подобные варианты. Количество значений в каждом вложенном кортеже должно соответствовать количеству аргументов.

Если в тестирующей функции нужен только один аргумент, то значения можно передавать простым списком или кортежем.

Тестирующая функция с декоратором `@pytest.mark.parametrize` будет запускаться до тех пор, пока не будут выполнены тесты со всеми переданными параметрами.

Запустите тест `test_one_more()` с ключом `-v`:

```
pytest test_example.py::test_one_more -v 
```

В терминал будут выведены такие строки:

```
test_example.py::test_one_more[4-5] PASSED                                 [ 50%]
test_example.py::test_one_more[3-5] FAILED                                 [100%] 
```

В Node ID тестов входят и передаваемые параметры. Можно дать им осмысленные имена — их передают в необязательном именованном аргументе `ids` декоратора `@pytest.mark.parametrize`:

```
...
@pytest.mark.parametrize(
    'input_arg, expected_result',
    [(4, 5), (3, 5)],
    ids=['First parameter', 'Second parameter',]
)
def test_one_more(input_arg, expected_result):
    ... 
```

Вывод станет таким:

```
test_example.py::test_one_more[First parameter] PASSED         [ 50%]
test_example.py::test_one_more[Second parameter] FAILED        [100%] 
```

Параметры в таких тестах можно отмечать маркерами «пропустить», «ожидаемое падение» и любыми другими.

Например, если ожидается, что с какими-то параметрами тест должен упасть — эти параметры указываются не в кортеже, а в аргументах функции `pytest.param()`; маркер указывается в именованном аргументе `marks`:

```
...
@pytest.mark.parametrize(
    'input_arg, expected_result',
    [
        (4, 5), 
        pytest.param(3, 5, marks=pytest.mark.xfail)  # Ожидается падение теста.
    ],
    ids=['First parameter', 'Second parameter',]
)
def test_one_more(input_arg, expected_result):
    ... 
```

На месте `xfail` может быть и другой маркер.

Обязательно запустите код: по отчёту будет понятна логика выполнения тестов; заодно станет понятен правильный ответ.

Сколько раз будет выполнен тест `test_cartesian_product()`?

```
def cartesian_product(a, b):
    return a * b


@pytest.mark.parametrize('x', [1, 2])
@pytest.mark.parametrize('y', ['one', 'two'])
def test_cartesian_product(x, y):
    assert cartesian_product(x, y) is not None 
```

Ни разу: будет выброшена ошибка

Один

Два

Правильный ответ

Четыре

Правильно! Столько есть сочетаний аргументов — столько раз и будет запущен тест.

