
[[Python]]
[[Фреймворк Django. Работа с проектами]]
[[Питон Практикум]]


В большинстве случаев для тестирования применяют готовые библиотеки: они предоставляют разработчику возможности гибкого запуска тестов, подробные отчёты, запуск одних и тех же тестов с разными параметрами — и многие другие приятные бонусы.

Работать с библиотеками значительно удобнее, чем писать тесты напрямую через `assert`. Например, при выполнении нескольких проверок через `assert` выполнение программы будет остановлено при первой же ошибке: если проверяемое утверждение не истинно — `assert` выбрасывает исключение, и выполнение программы прерывается. Библиотеки же позволяют выполнить весь набор тестов вне зависимости от того, с каким результатом выполнен тот или иной тест.

В 2022 году был проведён очередной ежегодный [опрос Python-разработчиков](https://lp.jetbrains.com/python-developers-survey-2022/), и он показал, что среди инструментов тестирования наиболее популярны

- **pytest** — внешняя, дополнительно устанавливаемая библиотека;
- **unittest** — часть стандартной библиотеки Python.

Большинство разработчиков пишет тесты либо на pytest, либо на unittest, либо и на том, и на другом одновременно:

|Тестовый фреймворк|Процент ответивших|
|---|---|
|pytest|51%|
|unittest|24%|
|mock|10%|
|doctest|6%|
|tox|6%|
|Hypothesis|5%|
|nose|4%|
|Other|1%|
|None|35%|

С математикой в опросе всё в порядке: респонденты могли выбрать несколько ответов, поэтому общая сумма в ответах — больше 100%.

Есть и другие инструменты тестирования, но в вакансиях для Python-разработчиков чаще всего встречаются именно pytest и unittest.

Вы познакомитесь с обеими библиотеками и изучите их специфику; это позволит вам гибко подходить к тестированию собственного кода. Помимо прочего, знакомство с этими инструментами повысит вашу ценность на рынке труда.

## Библиотека unittest

Unittest входит в стандартную библиотеку Python. При работе с этой библиотекой тесты пишутся по таким правилам:

- Разработчик создаёт специальный класс, унаследованный от `unittest.TestCase`. Этот класс может объединить в себе несколько отдельных тестов. Таких классов может быть сколько угодно.
- Каждый отдельный тест — это метод класса, унаследованного от `unittest.TestCase`. Разработчик придумывает имена этим методам и описывает в них необходимые утверждения и сообщения об ошибках.
- Имена методов класса должны начинаться с префикса `test_`.
- Вместо инструкций `assert` в unittest применяются методы класса `unittest.TestCase`. Названия методов начинаются со слова _assert_; вторая часть названия указывает, какую проверку проводит метод (например, метод `assertEqual()` проводит проверку на равенство). Этих методов довольно много, общий принцип их работы можно сопоставить с применением инструкции `assert`.
- В аргументы метода передаются:
    - проверяемое значение: например — результат вызова проверяемой функции;
    - ожидаемое значение (если необходимо); оно будет сравниваться с реальным значением;
    - сообщение об ошибке (оно будет выведено, если сравнение вернёт `False`).

Проверим состояние переменной методами библиотеки unittest и аналогичными выражениями assert.

```
x = 5 
```

|Методы в Unittest|Проверка через assert|
|---|---|
|assertEqual(x, 5, ‘Ошибка!’)|assert x == 5, 'Ошибка!’|
|assertIsInstance(x, int, 'Ошибка!')|assert isinstance(x, int), 'Ошибка!’|
|assertGreater(x, 2, 'Ошибка!')|assert x > 2, 'Ошибка!’|

## Тестируем микропрограмму

Рассмотрим работу unittest в реальном коде. Чтобы не смешивать тесты с кодом программы, сохраним тесты в отдельный файл.

Создайте файлы _code.py_ и _tests.py_:

```
любая_директория/     # Название не важно.
├── code.py           # Файл с тестируемым кодом.
└── tests.py          # Файл с тестами.
 
```

## Пишем код программы: code.py

В файле _code.py_ сохраните функцию `service_100()` — это импровизированная служба точного времени, именно её и будем тестировать:

```
# code.py
from datetime import datetime


def service_100():
    """Возвращает текущее время."""
    current_time = datetime.now()
    return current_time 
```

## Пишем тесты: tests.py

Импортируем в код библиотеку unittest и тестируемую функцию. Следом создадим первый класс для тестов: назовём его `TestTimeService` и унаследуем его от класса `unittest.TestCase`.

В классе напишем несколько методов-тестов:

- `test_time_is_running_out()`: проверит, что функция каждый раз возвращает новое время;
- `test_result_is_datetime()`: проверит, что возвращается объекта типа `datetime`.

По-английски такие методы называются **test case**, а в русском языке прижился перевод «тест».

Скопируйте код в файл _tests.py_:

```
# tests.py
import unittest
from datetime import datetime
from time import sleep

from code import service_100


class TestTimeService(unittest.TestCase):

    def test_time_is_running_out(self):
        first_time = service_100()
        sleep(1)
        second_time = service_100()
        self.assertNotEqual(first_time, second_time)

    def test_result_is_datetime(self):
        result = service_100()
        self.assertIsInstance(result, datetime)


unittest.main()  # Запуск тестов. 
```

## Запуск тестов

Для запуска тестов перейдите в директорию с файлом _tests.py_ и выполните команду

`python tests.py`.

Будет вызван метод `unittest.main()`, unittest найдёт в файле все классы, унаследованные от `unittest.TestCase`, и вызовет в них все методы, начинающиеся с `test_`.

Результат выполнения тестов будет отображён в консоли. По умолчанию каждый пройденный тест обозначается точкой, а каждый проваленный — буквой F; следом выводится время выполнения и общий итог прохождения всех тестов.

```
>>> python tests.py
..
----------------------------------------------------------------------
Ran 2 tests in 1.012s

OK  
```

Можно получить подробный отчёт о результатах, для этого нужно запустить тесты командой с флагом `-v` (`--verbose`, «подробно»): `python tests.py -v`

```
>>> python tests.py -v
test_result_is_datetime (__main__.TestTimeService) ... ok
test_time_is_running_out (__main__.TestTimeService) ... ok

----------------------------------------------------------------------
Ran 2 tests in 1.011s

OK 
```

По умолчанию тесты запускаются в алфавитном порядке, а не просто по очереди сверху вниз.

Запустить тесты можно иначе, обратившись к модулю unittest в терминале:

```
python -m unittest 
```

Ключ `-m` означает запуск модуля (в нашем случае — модуля unittest) как скрипта. При выполнении этой команды unittest найдёт в текущей и вложенных директориях все файлы, названия которых начинаются со слова _test_, и выполнит их — тоже в алфавитном порядке. При этом в файлах с тестами не требуется вызывать `unittest.main()`. Если эта строка будет в коде — при запуске тестов возникнет ошибка.

В проекте может быть много файлов с тестами, и командой `python -m unittest` можно запускать выборочно любой файл, класс с тестами или отдельный тестовый метод. Например, если в директории хранится несколько файлов с тестами:

```
tests/
├── test_one.py
├── test_two.py
└── test_three.py
 
```

…можно выполнить только часть тестов в этой директории; для этого в директории _/tests_ нужно выполнить команду

```
python -m unittest  # Запуск всех файлов с тестами (всех трёх).
python -m unittest test_one  # Запуск одного файла с тестами.
python -m unittest test_one test_two  # Запуск двух файлов с тестами.
python -m unittest test_one.TestClass  # Запуск отдельного класса с тестами.
python -m unittest test_one.TestClass.test_method  # Запуск отдельного теста. 
```

Прямо в консоли можно увидеть справку по применению команды `python -m unittest`, для этого выполните её с ключом `-h`:

```
python -m unittest -h 
```

## Падающие тесты

Предположим, в команду пришёл джуниор-специалист и решил провести небольшой рефакторинг кода — сократить количество строчек в функции, использовав параметры по умолчанию:

```
# code.py
from datetime import datetime


def service_100(current_time=datetime.now()):
    """Возвращает текущее время."""
    return current_time 
```

Скопируйте обновленный код к себе в файл.

А теперь снова запустите тесты. Если вы запускаете их командой `python -m unittest` — строчки `unittest.main()` в коде быть не должно.

Смотрим результаты тестирования… Барабанная дробь… Один тест провален!

В консоли появится примерно такой вывод:

```
>>> python -m unittest
.F
======================================================================
FAIL: test_time_is_running_out (tests.TestTimeService)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "<путь к файлу>", line 14, in test_time_is_running_out
    self.assertNotEqual(first_time, second_time)
AssertionError: datetime.datetime(2022, 10, 14, 18, 14, 25, 414626) == datetime.datetime(2022, 10, 14, 18, 14, 25, 414626)

----------------------------------------------------------------------
Ran 2 tests in 1.009s

FAILED (failures=1) 
```

В самой верхней строке вместо второй точки появилась буква F (_Failed_ — провален); ниже — информация о том, что именно пошло не так. В самом конце — общая сводка: «тесты провалены, количество проваленных тестов — 1».

Сама функция рабочая — один тест, что возвращается тип данных `datetime` по-прежнему успешно выполняется, а вот тест, который проверяет, что результат функции меняется с течением времени, провалился.

В выводе видно, что время, возвращаемое функцией не изменилось. Хотя прошла секунда — на это указывает время выполнения тестов. Причина в том, что если в параметрах функции в качестве значения по умолчанию стоит вызов функции, то она вызывается лишь единожды — в момент импорта модуля. Это значение запоминается, и потом при вызове функции будет возвращаться всегда одно и то же значение.

Тесты пригодились — нашлась ошибка, рефакторинг прошёл неудачно, надо откатывать изменения в программе назад.

## Выполнение до первого упавшего теста

Давайте поменяем названия тестовых методов, чтобы первым выполнялся тест с проверкой типа данных, а вторым — проверка «течения времени».

Переименуйте названия методов:

```
# К названию этого метода после слова test_ допишите латинскую букву a.
def test_time_is_running_out(self): 
# Чтобы получилось:
def test_a_time_is_running_out(self):

# А к названию этой функции после слова test_ допишите латинскую букву b.
def test_result_is_datetime(self):
# Чтобы получилось:
def test_b_result_is_datetime(self): 
```

Запустите тесты с ключом `-v`, их порядок изменился.

```
test_a_time_is_running_out (tests.TestTimeService) ... FAIL
test_b_result_is_datetime (tests.TestTimeService) ... ok 
```

Раньше падал второй по счёту тест, а теперь падает первый.

Представьте, что у вас не два теста, а две сотни тестов, и если хоть какой-то тест упал, вам уже неинтересно смотреть дальше, как пойдут результаты, а хочется сразу разобраться с ошибкой. В unittest есть возможность прервать выполнение тестов при первом падении какого-либо теста. Для этого надо запустить тесты с ключом `-f` (`--failfast`). Выполните эту команду в директории _/tests_:

```
python -m unittest -f 
```

Тестирование остановилось после того, как упал тест `test_a_time_is_running_out()`. Был выполнен только один тест вместо двух. Этот ключ удобен для отладки — при падении первого же теста процесс прекращается, и вы можете сразу перейти к исправлению ошибок в коде программы либо в самих тестах, смотря по тому, где именно затаился баг.

## Методы класса TestCase

Кроме уже рассмотренных выше методов `self.assert...` в unittest множество других методов на все случаи жизни. Например:

|Метод Unittest|Какое утверждение проверяется|Утверждаем, что…|
|---|---|---|
|assertTrue(x)|bool(x) is True|x — это True|
|assertFalse(x)|bool(x) is False|x — это False|
|assertIs(a, b)|a is b|a — тот же объект, что и b|
|assertIsNot(a, b)|a is not b|a — иной объект, чем b|
|assertIsNone(x)|x is None|x — это None|
|assertIsNotNone(x)|x is not None|x — это не None|
|assertIn(a, b)|a in b|a принадлежит коллекции b|
|assertNotIn(a, b)|a not in b|a не принадлежит коллекции b|
|assertNotIsInstance(a, b)|not isinstance(a, b)|a не относится к типу данных b|

[В официальной документации библиотеки unittest](https://docs.python.org/3/library/unittest.html#test-cases) описано более тридцати таких методов; выбор метода в каждом отдельном случае остаётся за разработчиком.

## Управление запуском тестов

Unittest позволяет не выполнять классы тестов и отдельные тесты. Для этого в библиотеке есть специальные декораторы:

- **@unittest.skip(reason)** — пропустить тест. В параметре `reason` можно описать причину пропуска.
- **@unittest.skipIf(condition, reason)** — пропустить тест, если условие `condition` истинно.
- **@unittest.skipUnless(condition, reason)** — пропустить тест, если условие `condition` ложно.

При необходимости некоторые тесты можно обозначить как ожидаемо провалившиеся.

- **@unittest.expectedFailure** — ставит на тесте отметку «ожидаемое падение»; провалившиеся тесты, обёрнутые этим декоратором, будут обозначены строкой  
    `expected failure`

Вот код, демонстрирующий варианты пропуска тестов:

```
import sys
import unittest


class TestExample(unittest.TestCase):
    """Демонстрирует возможности по пропуску тестов."""

    # Тест не будет запущен.
    @unittest.skip('Этот тест мы просто пропускаем')
    def test_show_msg(self):
        self.assertTrue(False, 'Значение должно быть истинным')

    # Тест будет запущен, если версия питона отлична от 3.9.
    @unittest.skipIf(sys.version_info.major == 3 and sys.version_info.minor == 9,
                     'Пропускаем, если питон 3.9')
    def test_python3_9(self):        
        # В декораторе skipIf можно проверять версии библиотек, 
        # доступность внешних сервисов,
        # время или дату - любые данные.
        pass

    # Тест будет запущен только в Linux.
    @unittest.skipUnless(sys.platform.startswith('linux'), 'Тест только для Linux')
    def test_linux_support(self):        
        pass

    # Ожидаем, что этот тест будет провален.
    @unittest.expectedFailure
    def test_fail(self):
        self.assertTrue(False, 'Ожидаем истинное значение') 
```

Сохраните этот код во временный файл _test_skip.py_ и запустите тесты с ключом `-v`, чтобы вывести в консоль подробные результаты тестов:

```
python -m unittest -v test_skip.py 
```

При запуске этого теста в OC Linux с Python 3.9 будет такой вывод в консоль:

```
test_fail (skip_test.TestExample) ... expected failure
test_linux_support (skip_test.TestExample) ... ok
test_python3_9 (skip_test.TestExample) ... skipped 'Пропускаем, если питон 3.9'
test_show_msg (skip_test.TestExample) ... skipped 'Этот тест мы просто пропускаем'

----------------------------------------------------------------------
Ran 4 tests in 0.000s

OK (skipped=2, expected failures=1) 
```

А в OC Windows с Python 3.8 картина будет иная: метод `test_linux_support` вернёт _skipped_, а метод `test_python3_9` отработает и вернёт _ok_:

```
test_fail (skip_test.TestExample) ... expected failure
test_linux_support (skip_test.TestExample) ... skipped 'Тест только для Linux'
test_python3_9 (skip_test.TestExample) ... ok
test_show_msg (skip_test.TestExample) ... skipped 'Этот тест мы просто пропускаем'

----------------------------------------------------------------------
Ran 4 tests in 0.000s

OK (skipped=2, expected failures=1) 
```

## Ожидаемое падение vs проверка на исключение

Стоит отличать ситуацию, когда тест ожидаемо падает от ситуации, когда функция обязана выбросить исключение.

В первом случае ставится декоратор `@unittest.expectedFailure`, а во втором нужно проводить проверку утверждения «выброшено исключение». Для такой проверки в unittest есть метод `assertRaises`.

Самый простой способ применения метода `assertRaises` — через контекстный менеджер, конструкцию с ключевым словом `with`:

```
import unittest


def division_func(a, b):
    """Функция деления одного числа на другое."""
    return a / b


class TestExample(unittest.TestCase):

    @unittest.expectedFailure
    def test_fail(self):
        self.assertTrue(False, 'Ожидаем истинное значение')

    def test_zero_division(self):
        # Используем метод assertRaises как контекстный менеджер 
        # (записываем его со словом with); указываем ожидаемый тип исключения -
        # "ошибка деления на ноль".
        with self.assertRaises(ZeroDivisionError):
            # Передаём в функцию division_func() аргументы 1 и 0. На ноль делить нельзя,
            # поэтому должна быть вызвана ошибка ZeroDivisionError.
            division_func(1, 0) 
```

Скопируйте код в пустой файл и запустите тест.

При запуске первый тест просто упал, но был помечен, как ожидаемо упавший, а второй тест в процессе выполнения вызвал ошибку. Именно эта ошибка и ожидалась, следовательно тест прошёл успешно.

Если в `assertRaises` нужно передать сообщение об ошибке, то это делается при помощи именованного аргумента `msg`:

```
...
with self.assertRaises(ZeroDivisionError, 
                       msg='Ожидалась ошибка деления на ноль'):
    division_func(1, 0) 
```
