
[[Python]]
[[Фреймворк Django. Работа с проектами]]
[[Питон Практикум]]

# Unittest в Django

Тестирование — стандартная процедура при разработке любой программы, поэтому авторы Django не обошли вниманием эту сторону разработки и включили в состав фреймворка собственный [модуль для тестирования](https://docs.djangoproject.com/en/3.2/topics/testing/). Его основой стала библиотека unittest: разработчики адаптировали её для Django, добавив в неё специализированные методы для тестирования фреймворка.

## Проект YaNews

Чтобы изучить работу с тестами — нужно что-нибудь потестировать. Полигоном для тестов будет Django-проект **YaNews**: новостной сайт, где пользователи могут оставлять комментарии к новостям.

Разверните на своём компьютере проект YaNews:

1. На своём компьютере в директории с проектами создайте папку для проекта YaNews.
2. Склонируйте проект YaNews из [репозитория](https://github.com/yandex-praktikum/ya_news/): `git clone …`
3. Создайте виртуальное окружение `python -m venv venv`
4. Запустите виртуальное окружение и установите зависимости из файла _requirements.txt_: `pip install -r requirements.txt`
5. Миграции уже созданы, выполните их: `python manage.py migrate`.
6. Cоздайте суперпользователя: `python manage.py createsuperuser`.
7. Для заполнения базы данных новостями, выполните команду `python manage.py loaddata news.json`.
8. Запустите проект.

Добро пожаловать в проект! Знакомьтесь:

- На главной странице проекта отображаются 10 последних новостей. Главная страница доступна любому пользователю. Новости отображаются в сокращённом виде (видно только первые 15 слов).
- У каждой новости есть своя страница, с полным текстом новости; там же отображаются и комментарии пользователей.
- Любой пользователь может самостоятельно зарегистрироваться на сайте.
- Залогиненный (авторизованный) пользователь может оставлять комментарии, редактировать и удалять свои комментарии.
- Если к новости есть комментарии — их количество отображается на главной странице под новостью.
- В коде проекта есть список запрещённых слов, которые нельзя использовать в комментариях, например, «редиска» и «негодяй».

Попробуйте создать несколько комментариев от имени своего пользователя, какие-то отредактировать, а какие-то — удалить.

Загляните в код проекта: посмотрите, как он устроен, из каких приложений состоит, что есть внутри приложений, как устроены шаблоны. Более подробно с кодом вы познакомитесь в ходе написания тестов, а пока что хватит и краткого обзора.

## План тестирования

Ваша ближайшая задача — протестировать проект, а для этого нужно спланировать, что именно нужно тестировать, а что не стоит.

Будем тестировать:

В файле _test_routes.py_:

- Главная страница доступна анонимному пользователю.
- Страница отдельной новости доступна анонимному пользователю.
- Страницы удаления и редактирования комментария доступны автору комментария.
- При попытке перейти на страницу редактирования или удаления комментария анонимный пользователь перенаправляется на страницу авторизации.
- Авторизованный пользователь не может зайти на страницы редактирования или удаления чужих комментариев (возвращается ошибка 404).
- Страницы регистрации пользователей, входа в учётную запись и выхода из неё доступны анонимным пользователям.

В файле _test_content.py_:

- Количество новостей на главной странице — не более 10.
- Новости отсортированы от самой свежей к самой старой. Свежие новости в начале списка.
- Комментарии на странице отдельной новости отсортированы от старых к новым: старые в начале списка, новые — в конце.
- Анонимному пользователю недоступна форма для отправки комментария на странице отдельной новости, а авторизованному доступна.

В файле _test_logic.py_:

- Анонимный пользователь не может отправить комментарий.
- Авторизованный пользователь может отправить комментарий.
- Если комментарий содержит запрещённые слова, он не будет опубликован, а форма вернёт ошибку.
- Авторизованный пользователь может редактировать или удалять свои комментарии.
- Авторизованный пользователь не может редактировать или удалять чужие комментарии.

Не будем тестировать:

- Непосредственно регистрацию пользователей, процесс входа в учетную запись и выхода из неё.
- Всё, что связано с админ-зоной проекта.
- Абсолютные url-адреса; обращаться к адресам будем при помощи функции `reverse('name')`.
- Какие шаблоны используются, и насколько корректно шаблон обрабатывает полученную от Django информацию. Например, если в шаблон передается список объектов, мы будем считать, что они выводятся все, а их сортировка не меняется.
- Всё то, что не попало в список «будем тестировать».

Отдельно стоит сказать про шаблоны. Чтобы проверить, как именно шаблон выводит информацию, зачастую в тестах надо исследовать HTML; не будем этим заниматься. Будем считать, что шаблон написан корректно и выводит то, что нужно, а разработчик проверил это на этапе работы над приложением.

Дополнительно в тестах мы исходим из того, что атрибуты объектов моделей передаются в контекст шаблона в неизменном виде. То есть в проекте нет кода, который «по пути» из моделей в шаблоны изменяет атрибуты объекта. Да, это можно было бы проверить, но это представляется излишним.

В тестах можно проверять множество мелочей, но надо соблюдать баланс и уметь вовремя остановиться. Важно проверить критичный для приложения функционал, логику, написанную самим разработчиком, и тот функционал, который может быть изменён.

Например, регистрация пользователей, авторизация и выход из аккаунта — это, по большей части, работа самого Django-фреймворка, и для этих действий тесты можно не писать: разработчики Django много раз всё это протестировали.

При работе над приложением можно вручную проверить, что это работает; если в дальнейшем этот функционал не будет меняться — то и проверять его автоматизированными тестами нет особой необходимости.

## Запуск и обнаружение тестов

Сейчас в Django-проекте нет ни одного теста, но модуль для тестирования уже готов к работе — и можно выполнить команду поиска и запуска тестов.

Тесты в Django запускаются командой `python manage.py test`. Django будет искать тесты в пакетах текущей директории и во всех вложенных пакетах, в файлах с именем `test*.py`. Вместо символа «звёздочка» может быть любой набор символов, например, будут найдены файлы с именами _test_models.py_, _test_content.py_, _testsomethingelse.py_.

Вот пример структуры, в которой каждый из файлов будет найден и распознан как тест. Чтобы структура выглядела полегче — из неё удалены все файлы, кроме тестов и файлов `__init__.py`.

В директориях с тестами обязательно должен быть файл `__init__.py`

```
└── <app_name>/
    ├── tests/
    |   ├── __init__.py
    |   └── test.py
    ├── yet_another_dir_with_tests/
    |   ├── subdir_for_tests/
    |   |   ├── __init__.py
    |   |   └── test.py
    |   ├── __init__.py
    |   └── test.py
    ├── __init__.py
    ├── test.py
    ├── test_all.py
    ├── tests.py
    └── testsomethingnew.py 
```

Если в проекте YaNews выполнить команду `python manage.py test`, то в консоль будет выведен такой ответ:

```
System check identified no issues (0 silenced).

----------------------------------------------------------------------
Ran 0 tests in 0.000s  # Запущено 0 тестов, они выполнены за 0 секунд.

OK                     # Всё прошло без ошибок. 
```

Логично: нет тестов — нет ошибок. Тем не менее — модуль тестирования сделал всё что мог: поискал тесты, не нашёл, вывел отчёт.

### Где живут тесты Django

При выполнении команды «создать новое приложение» `python manage.py startapp <app_name>` в директории приложения автоматически создаётся файл для тестов `tests.py`:

```
└── <app_name>/
    ├── migrations/
    ├── __init.py__
    ├── admin.py
    ├── apps.py
    ├── models.py
    ├── tests.py   # Файл для тестов.
    └── views.py 
```

Это лучше, чем ничего, но на практике размещение всех тестов в одном файле приведёт к тому, что файл раздуется и станет плохо читаемым.

Лучше делать так:

1. Удалить файл _tests.py_ (если его не удалить, то может возникнуть путаница между модулем _tests.py_ и пакетом _tests_ из следующего шага).
2. Создать в директории приложения **пакет** `tests`: создать директорию _tests/_ и разместить в ней пустой файл `__init__.py`_._
3. В пакете `tests` создать отдельные файлы для тестов.

Есть разные подходы к тому, как называть файлы с тестами и какие тесты в каких файлах сохранять. Например, можно построить структуру файлов с тестами на основе файлов приложения: тесты для кода из _views.py_ хранить в файле _test_views.py_, а тесты для _models.py_ — в _test_models.py_. Следуя этой логике, в директории с тестами следует создать файлы для тестирования моделей, представлений, форм и адресов:

```
└── <app_name>/
    ├── migrations/
    ├── tests/
    │   ├── __init__.py  
    │   ├── test_forms.py   # Тесты форм. 
    │   ├── test_models.py  # Тесты моделей.
    │   ├── test_urls.py    # Тесты адресов.    
    │   └── test_views.py   # Тесты представлений.
    ├── __init__.py
    ├── admin.py
    ├── apps.py
    ├── models.py
    └── views.py 
```

У такого подхода есть недостаток — обычно логика работы приложения распределена между разными файлами, и непонятно, где именно её тестировать:

1. Где тестировать доступность эндпоинта для авторизованного юзера, если эндпоинт описан в _urls.py_, а необходимость авторизации пользователя — во _views.py_?
2. Где тестировать шаблоны для view-классов, если они могут быть указаны и во _views.py_, и в _urls.py_?
3. Где тестировать форму, если она описывается в _forms.py_, а логика работы с ней — во _views.py_?

Есть и другая логика для структурирования тестов: их можно расположить по функциональному признаку, без жёсткой привязки к тому, в каком конкретно файле находится проверяемый код:

```
└── <app_name>/
    ├── migrations/
    ├── tests/
    │   ├── __init__.py  
    │   ├── test_content.py  
    │   ├── test_logic.py
    │   └── test_routes.py
    ├── __init__.py
    ├── admin.py
    ├── apps.py
    ├── models.py
    └── views.py 
```

При этом подходе логика распределения тестов по файлам будет такой:

- _test_content_ — тесты, касающиеся отображения контента. Какие данные на каких страницах отображаются, какие при этом используются шаблоны, как работает пагинатор.
- _test_logic_ — тестирование бизнес-логики приложения. Как обрабатываются те или иные формы, разрешено ли создание объектов с неуникальными полями, как работает специфичная логика конкретного приложения.
- _test_routes_ — тесты доступности конкретных эндпоинтов, проверка редиректов, кодов ответа, которые возвращают страницы, тестирование доступа для авторизованных или анонимных пользователей.

Именно такой схемы расположения тестов мы и будем придерживаться в уроках.

Прежде, чем переходить к следующему уроку, создайте в приложении _news_ проекта YaNews пакет `tests`, а в нём — пять пустых файлов:

- `__init__.py`: этот файл указывает, что директория — это пакет Python,
- `test_content.py`,
- `test_logic.py`,
- `test_routes.py`,
- `test_trial.py`: это файл для экспериментов с тестами.

## Домашнее задание

Очередной проект, с которым вам предстоит поработать, — это Django-проект YaNote, электронная записная книжка для тех, кто не хочет ничего забыть и поэтому всё записывает.

Клонируйте проект из [репозитория](https://github.com/yandex-praktikum/ya_note), настройте его на своём компьютере и познакомьтесь с ним. После знакомства с проектом YaNote выполните первое задание: напишите план тестирования этого проекта. В дальнейшем этот план вам понадобится при написании тестов.

Обратите внимание на особенность проекта — если в форме при создании заметки не заполнено поле `slug`, то в качестве адреса страницы будет установлено транслитерированное название заметки; поле `slug` должно быть уникальным.
