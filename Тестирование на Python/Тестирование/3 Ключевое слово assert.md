
[[Python]]
[[Фреймворк Django. Работа с проектами]]
[[Питон Практикум]]

# Ключевое слово assert

Начинаем писать код. Первым делом разберёмся с **утверждениями** (_assertions_) — именно на них построено тестирование.

Инструкция `assert` есть практически в каждом популярном языке программирования, и Python — не исключение. В переводе с английского _to assert_ означает «утверждать».

Ключевое слово `assert` позволяет в любом месте программы

- сделать предположение о выполнении какого-либо условия;
- проверить, выполняется ли условие;
- в случае, если условие не выполнено — вернуть сообщение об ошибке.

В `assert` можно сделать предположение о значении переменной, о результате работы функции или класса — о любом выражении, которое можно оценить как истинное или ложное.

```
x = 5

# Делаем утверждение: "переменная x равна пяти"
# Синтаксис: assert <утверждение>, 'Cообщение об ошибке'
assert x == 5, 'Сообщение, которое вернётся, если утверждение не истинно'
# Утверждение вернёт True, так что сообщение не будет показано

assert x == 4, 'Сообщение, которое вернётся, если утверждение не истинно'
# Утверждение x == 4 вернёт False, и в этом случае в консоль будет выведено
# ...
# AssertionError: Сообщение, которое вернётся, если утверждение не истинно
 
```

Если условие истинно — ничего не произойдёт и программа продолжит работу. А вот если условие ложно — программа выбросит исключение `AssertionError`, остановится и выведет сообщение об ошибке.

Инструкция `assert` используется для отладки программы: разработчик размещает в нужных местах программы такие выражения, и если что-то пойдёт не по плану — `assert` выкинет сообщение об ошибке.

Кроме того, утверждения `assert` покажут другим программистам в команде, что ожидается в конкретном месте кода; это своего рода документация. На базе `assert`-выражений и их производных строятся все библиотеки тестирования, с чем мы познакомимся чуть позже. А пока что давайте разберём синтаксис `assert`-выражений:

```
assert <проверяемое утверждение>[, 'Опциональное сообщение об ошибке'] 
```

Посмотрим ещё несколько примеров. Присоединяйтесь: создайте пустой файл и погоняйте примеры в редакторе кода.

В этом примере утверждение истинно:

```
x = [0, 1, 2, 3, 4]
assert len(x) == 5, f'Хьюстон, у нас проблемы: значение len(x) равно {len(x)}!'
# Утверждение len(x) == 5 истинно, так что
# код продолжит выполняться, а сообщение не будет выведено. 
```

А здесь утверждение ложно:

```
x = [0, 1, 2, 3, 4]
# Добавим элемент:
x.append(5)
# ...и посмотрим, верно ли утверждение
assert len(x) == 5, f'Хьюстон, у нас проблемы: значение len(x) равно {len(x)}!'

# В результате будет вызвано исключение с сообщением об ошибке,
# а выполнение кода будет остановлено:
#     assert len(x) == 5, f'Хьюстон, у нас проблемы: значение len(x) равно {len(x)}!'
# AssertionError: Хьюстон, у нас проблемы: значение len(x) равно 6! 
```

Сообщение об ошибке указывать необязательно, если ошибка очевидна.

```
assert 2 + 2 == 5

# Вывод будет таким:

#     assert 2 + 2 == 5
# AssertionError 
```

## Пара слов об исключениях

Вы уже сталкивались с исключениями (Exceptions) в Python. Исключения — это ошибки, возникающие при исполнении программы. Классический пример: в функцию, выполняющую деление, в качестве делителя передан ноль; сама функция не содержит ошибок, а проблема возникает только при её вызове с определёнными аргументами.

При возникновении исключения Python прерывает выполнение программы и выводит в консоль сообщение.

Исключения могут быть различного типа, их названия, как правило, содержат слово `Error`:

`ZeroDivisionError` — попытка деления на ноль;

`KeyError` — не найден ключ (в словаре, например);

`TypeError` — ошибка типа данных, неподходящий тип данных.

В числе исключений есть и `AssertionError`; оно появляется, когда при проверке выражения `assert` вернулось `False`.

При возникновении ошибок при исполнении кода Python автоматически создаёт исключения, но при необходимости разработчик может и сам вызвать их в нужном месте кода. Для этого применяется ключевое слово `raise`, после которого указывается тип исключения и, при необходимости, сообщение об ошибке. Слово _raise_ в этом контексте означает «вызвать»; в русском языке иногда используют выражение «выбросить исключение».

```
print('Меня зовут Бонд.')
raise NameError('С таким именем нельзя продолжать работу')  # Выбрасываем исключение.
print('Джеймс Бонд.') 
```

В этом коде полное имя персонажа никогда не будет напечатано — ведь на второй строке программа остановится:

```
Меня зовут Бонд.
Traceback (most recent call last):
  File "<путь до файла>", line 2, in <module>
      raise NameError('С таким именем нельзя продолжать работу')
NameError: С таким именем нельзя продолжать работу

Process finished with exit code 1 
```

Выбрасывать исключение можно при выполнении какого-нибудь условия:

```
name = 'Джеймс Бонд'
if name == 'Джеймс Бонд':
    raise NameError('Обнаружено имя шпиона!')
print(f'Добро пожаловать, {name}!') 
```

В этом примере вызвана ошибка `NameError`, но это такая шутка: на самом деле тип `NameError` применяется, когда программе неизвестно, например, имя переменной.

Встроенные типы исключений [перечислены в документации](https://docs.python.org/3/library/exceptions.html#concrete-exceptions); разработчик может описать и собственный тип исключений (для приведённого примера можно было бы создать исключение `SpyDetectedError`).

### Форматирование кода assert

Сообщение об ошибке в `assert` может быть довольно длинным, и линтеры будут протестовать против нарушения PEP8; сообщение придётся разбить на несколько строк.

При переносе строк в `assert` есть важный нюанс: **нельзя заключать в общие скобки проверяемое утверждение и сообщение об ошибке**; при таком синтаксисе Python воспримет выражение в скобках как кортеж из двух элементов, а при проверке на истинность непустой кортеж всегда возвращает `True`.

```
# При выполнении этого кода Python решит,
# что 5 == 4 - это первый элемент кортежа,
# а строка с сообщением - второй его элемент.
assert (5 == 4, 'Очень длинная строка, в которой многословно '
        'и с лирическими отступлениями описывается, '
        'какой именно тест провален.')
# Сообщение об ошибке не будет показано:
# утверждение будет воспринято как кортеж,
# а кортеж — это всегда True. 
```

Создайте файл _check_assert.py_, скопируйте в него код из листинга и запустите файл. Несмотря на абсурдность утверждения `5 == 4`, сообщение об ошибке не будет показано.

Но Python заподозрит неладное и спросит: «утверждение всегда истинно, может, стоит убрать скобки?»:

```
<path to file>:3: SyntaxWarning: assertion is always true, perhaps remove parentheses?
  assert (5 == 4, 'Очень длинная строка, в которой многословно ' 
```

Линтер в IDE тоже может выдать предупреждение:

![](https://pictures.s3.yandex.net/resources/image_1700487750.png)

При переносе длинных строк в `assert` заключайте в скобки **только сообщение об ошибке**:

```
assert 5 == 4, ('Очень длинная строка, в которой многословно '
                'и с лирическими отступлениями описывается, '
                'какой именно тест провален.') 
```

Теперь всё сработает как следует: при выполнении этого кода вернётся сообщение об ошибке:

```
Traceback (most recent call last):
  File <path to file>:, line 1, in <module>
    assert 5 == 4, ('Очень длинная строка, в которой многословно '
AssertionError: Очень длинная строка, в которой многословно и с лирическими отступлениями описывается, какой именно тест провален. 
```

## Assert для функции

Потестируем при помощи `assert` более сложный код: скопируйте его из листинга в файл _check_assert.py_ и запустите.

```
# check_assert.py
def movie_quotes(name):
    """Возвращает цитаты известных персонажей из фильмов."""
    quotes = {
        'Элли': 'Тото, у меня такое ощущение, что мы не в Канзасе!',
        'Шерлок': 'Элементарно, Ватсон!',
        'Дарт Вейдер': 'Я — твой отец.',
        'Thomas A. Anderson': 'Меня зовут Ханс. Ханс Кристиан Андерсен.',
    }
    return quotes.get(name, 'Такого персонажа нет.')



# Утверждаем, что если в movie_quotes() передать 'Шерлок' -
# функция вернёт 'Элементарно, Ватсон!'.
assert movie_quotes('Шерлок') == 'Элементарно, Ватсон!', 'Тест провален'

# Утверждаем, что если в movie_quotes() передать 'Thomas A. Anderson' -
# функция вернёт 'Меня. Зовут. Нео!'.
assert movie_quotes('Thomas A. Anderson') == 'Меня. Зовут. Нео!', 'Тест провален'

# Утверждаем, что если в movie_quotes передать 'Алиса Плезенс Лидделл' -
# функция вернёт 'Всё чудесатее и чудесатее!'.
expected_answer = 'Всё чудесатее и чудесатее!'
assert movie_quotes('Алиса Плезенс Лидделл') == expected_answer, 'Тест провален' 
```

**Тест провален:** при вызове `movie_quotes('Thomas A. Anderson')` функция вернула не тот ответ, который ожидался; Нео зачем-то представился именем великого сказочника.

Измените значение в словаре `quotes` в элементе с ключом `Thomas A. Anderson`: вместо `'Меня зовут Ханс. Ханс Кристиан Андерсен.'` поставьте `'Меня. Зовут. Нео!'` и запустите код ещё раз.

**Снова провал**: тест с Нео прошёл, но в словаре нет Алисы; вызов функции `movie_quotes()` с аргументом `'Алиса Плезенс Лидделл'` вместо ожидаемого ответа `'Всё чудесатее и чудесатее!'` вернул `'Такого персонажа нет.'`. Это ошибка, надо её исправить, ведь вокруг — страна чудес.

Добавьте в словарь `quotes` ещё один элемент: ключ — `'Алиса Плезенс Лидделл'`, значение — `'Всё чудесатее и чудесатее!'`. Запустите код.

**Сработало, код в порядке!** Ни одного сообщения об ошибке, тесты пройдены, программа работает!

## Assert для метода класса

Потестируем методы класса, описывающего записи в контакт-листе. Скопируйте код из листинга в файл:

```
class Contact:

    def __init__(self, name, year_birth, is_programmer):
        self.name = name        
        self.year_birth = year_birth        
        self.is_programmer = is_programmer

    def age_define(self):
        if 1946 < self.year_birth < 1980:
            return 'Олдскул'
        if self.year_birth >= 1980:
            return 'Молодой'
        return 'Старейшина'

    def programmer_define(self):
        if self.is_programmer:
            return 'Программист'
        return 'нормальный'

    def show_contact(self):
        return (f'{self.name}, '               
                f'категория: {self.age_define()}, '
                f'статус: {self.programmer_define()}') 
```

Метод `show_contact()`, вызванный для объекта класса `Contact`, возвращает строку: имя человека, его «категорию» по возрасту и его статус — «Программист» или «Нормальный».

Можно создать объект класса `Contact`:

```
bill_gates = Contact(name='Билл Гейтс', year_birth=1955, is_programmer=True) 
```

Если вызвать для этого объекта метод `show_contact()` и напечатать результат вызова — будет выведена такая строка:

```
print(bill_gates.show_contact())
# Билл Гейтс, категория: Олдскул, статус: Программист 
```

Чтобы протестировать методы этого класса при помощи `assert`, проще всего создать экземпляр класса и убедиться, что поведение класса соответствует ожиданиям: экземпляр создаётся, метод вызывается.

Проверим, правильно ли работает метод `show_contact()` класса `Contact`, для этого создадим запись с новыми данными:

```
# Создаём экземпляр класса Contact
mike = Contact('Михаил Булгаков', 1891, False)

# Заготавливаем строку, которую по ожиданию должен вернуть метод show_contact():
expected_string = 'Михаил Булгаков, категория: Старейшина, статус: Нормальный'

# Пишем утверждение: 
# "вызов метода show_contact объекта mike вернёт строку, сохранённую в expected_string"
assert mike.show_contact() == expected_string, 'Метод show_contact работает некорректно!' 
```

Тест провален! В консоли сообщение `AssertionError: Метод show_contact работает некорректно!`.

Утверждение в `assert` ожидает строку, где слово «Нормальный» написано с большой буквы, а в методе `programmer_define()` это слово написано с маленькой. Попался, баг!

Поправьте ошибку в методе `programmer_define()` и повторно выполните код. В консоли — ничего. Это хороший признак, ошибки не найдены!
