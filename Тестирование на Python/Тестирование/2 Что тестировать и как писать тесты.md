
[[Python]]
[[Фреймворк Django. Работа с проектами]]
[[Питон Практикум]]

# Что тестировать и как писать тесты?

В теории тестирования есть такой принцип: «Исчерпывающее тестирование невозможно». В применении к разработке это означает, что на практике невозможно протестировать проект полностью, с учётом всех возможных предусловий и комбинаций входящих данных. Звучит сложно, но если по-простому, то при написании тестов не стоит впадать в перфекционизм и стараться проверить «ну вот вообще всё».

В идеале нужно протестировать весь написанный код. Например, в Django-проекте нет нужды тестировать сам фреймворк: его уже проверили разработчики Django. А вот вся логика приложения, например, модели, view-функции и классы, формы — это должно быть протестировано.

Иногда на тесты уходит больше времени, чем на тот код, который они проверяют. И чтобы зря не тратить время, нужно помнить о здравом смысле.

Нужно покрывать тестами код, который критичен для работы приложения. Писать ли тесты на некритичные части кода — решать самому разработчику.

При тестировании важно найти баланс: тестировать необходимое и не тестировать второстепенное. Это как с комментированием кода — нет смысла комментировать каждую строку кода, но и оставлять код вовсе без комментариев тоже не стоит.

Никто не мешает написать 100500 тестов к приложению, однако эти тесты придётся поддерживать при изменениях в приложении, а стороннему разработчику придётся разбираться не только в проекте, но и в огромном количестве тестов.

Как правило, тесты пишутся перед тем, как «запушить» что-либо в репозиторий. Любой код, который вы отправляете в репозиторий, должен быть протестирован. Воспринимайте это как правило хорошего тона. Разумеется, это в том случае, если ваша команда не работает по методологии TDD, где тесты пишутся **до** написания кода.

К сожалению, не любой код, скачанный из репозиториев, имеет тесты. Но если вы планируете работать с чужим кодом, а в репозитории есть тесты — обязательно запускайте их в проекте всякий раз, как скачаете обновления кода.

Для экономии времени. Представьте: вы скачиваете из чужого репозитория проект и, не запуская тестов, пишете новую функцию и тесты к ней. Потом запускаете все тесты — и б**о**льшая часть тестов проваливается, в том числе старые, написанные до вас. И встаёт вопрос — всё сломалось в связи с вашими правками или же тесты проваливались и в исходном проекте?

Но если запустить тесты до начала работы — такого вопроса не возникнет, это факт: либо тесты отработают корректно, либо сразу будут видны ошибки.

## Рекомендации для написания тестов

Как правило, unit-тесты — это набор классов или функций, которые проверяют корректность работы классов и функций программы. В методе тестирующего класса или в функции проводится проверка истинности какого-то утверждения. Каждый такой метод или функция — это и есть «тест».

Если мы говорим о веб-проекте, то один тест может проверять, открывается ли главная страница, другой — правильно ли сохраняются объекты в БД, третий — корректно ли выводится на страницу информация из БД.

После выполнения тестов автоматически создаётся отчёт, в котором сказано, какой из тестов успешно выполнен, а какой — вернул ошибку, «провалился».

### Один тест — одна проверка

Каждый тест должен проверять что-то одно — одну операцию, одну функцию, один метод; так будет проще найти и локализовать ошибку. Это называется «атомарность» тестов.

Если в одном тесте выполняется несколько проверок и одна из них вернёт `False` — выполнение теста остановится, остальные проверки в этом тесте не будут выполнены; начнёт выполняться следующий тест.

До тех пор, пока в коде не будет исправлена ошибка, вызвавшая False при проверке — результаты остальных проверок в этом тесте будут неизвестны и разработчик не получит часть информации о том, как работает программа.

Нет правил без исключений, но в большинстве случаев лучше придерживаться правила «один тест — одна проверка».

![](https://pictures.s3.yandex.net/resources/sprint4_picture1_1687357117.png)

### Независимость тестов

Тесты должны быть независимы друг от друга; правильно написанные тесты можно запускать все вместе, а можно — по одному, в любом порядке.

Предположим, в интернет-магазине нужно протестировать добавление и удаление товаров в корзину. Принцип «один тест — одна проверка» говорит, что должно быть написано два теста: проверка добавления товара в корзину и проверка удаления товара.

Взаимозависимые тесты будут устроены так: первый тест добавляет товар в корзину и проверяет, что товар добавился. Второй тест удаляет из корзины товар, добавленный в первом тесте и проверяет, что в корзине пусто. Проблема: второй тест без первого не запустить! Чтобы протестировать удаление товара — придётся запускать два теста вместо одного. А если первый тест провалится — то провалится и второй; будет сложнее разобраться, где проблема.

Независимые тесты будут устроены иначе. В первом тесте всё остаётся по-прежнему: в корзину добавляется товар, а затем проводится проверка, что товар действительно добавлен. А во второй тест должен быть включен подготовительный этап — в корзину должен добавляться товар. При тестировании этот товар будет удаляться, и после этого будет выполнена проверка, что корзина пуста.

Взаимозависимые тесты нельзя выполнить в произвольном порядке: если второй тест запустится раньше первого, то будет нечего удалять из корзины. В независимых тестах результаты выполнения одного теста не влияют на результаты другого.

### Идемпотентность тестов

**Идемпотентным** называют такой тест, который возвращает один и тот же результат при любом количестве запусков. Например, при тестировании счётчика товаров в корзине интернет-магазина можно в начале теста добавлять в корзину три товара и проверять, что количество товаров отображается верно. Если тест идемпотентный — то при каждом его запуске в корзине должно оказываться именно три товара, то есть в начале теста корзина должна быть пустой.

Для поддержки идемпотентности тестов при работе с базами данных все современные тестирующие фреймворки позволяют выполнять операции в так называемых **транзакциях**; на практике это, например, означает, что все изменения, которые были внесены в базу при выполнении конкретного теста, по окончании этого теста будут отменены.

Если при выполнении теста необходимо создать какие-нибудь файлы, то принцип идемпотентности требует, чтобы эти файлы были удалены после выполнения теста.

### Проверка позитивных и негативных случаев

Тесты должны проверять не только то, что функция работает правильно, но и случаи, когда на вход подаются неправильные данные или не соблюдаются требуемые условия. Продолжая пример с корзиной в интернет-магазине, можно проверить, что в корзину невозможно добавить товар, которого нет в наличии.
