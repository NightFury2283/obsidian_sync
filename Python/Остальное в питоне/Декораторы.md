[[Декораторы для методов класса]]
[[Python]]
[[Питон Практикум]]

**Декораторы** для функций позволяют добавить к функции определённые действия или изменить её поведение, не вмешиваясь в код самой функции.


## Фундамент декораторов

Для начала стоит сформулировать и разобрать два важных принципа, они пригодятся в работе:

1. Функции в Python — это **объекты**.
2. Функции могут содержать в себе другие функции.


**Однако функция — особенный объект.** Это как «коробочка с механизмом и с кнопкой»: она лежит и ждёт, когда «нажмут на кнопку» — вызовут функцию. Объект, который можно вызвать для выполнения какой-то работы, называется _callable object_. Функция как раз и относится к таким объектам.


Функции принимают на вход **объекты** — например, числа, строки или списки. Раз функция — это тоже объект, значит, ничто не мешает передать на вход одной функции объект другой функции.

И вот тут важно не запутаться. Функция — это объект. Но функция — это объект, который можно вызвать и получить результат вызова функции. **Функция как объект** и **результат вызова** функции — это совершенно разные сущности.

Проверим на практике: сначала передадим в функцию `print()` **результат вызова** функции `say_hello()`, а затем — **объект** этой функции.


```
def say_hello():
    return 'Привет!'

# Передаём в print() результат вызова функции:
# вызов функции записывается с круглыми скобками после названия функции.
print('Передали вызов функции:')
print(say_hello())

# Передаём в функцию print() объект функции:
# не ставим скобки после имени функции say_hello:
print('Передали объект функции:')
print(say_hello)
```


**Результат**

```
Передали вызов функции:
Привет!
Передали объект функции:
<function say_hello at 0x7fb7d4f52e50>
```


### Функции внутри других функций

Объект функции можно передать как аргумент в другую функцию, доказано. А если уж передали — то почему бы и не вызвать функцию-аргумент внутри «внешней» функции?


```
def outer_function(func):
    # Вызываем функцию, полученную в аргументе func:
    result = func('Стас')
    print(result)


def say_hello(name):
    return f'Привет, {name}!'


# Передаём say_hello как объект - без скобок!
outer_function(say_hello)
```


### Замеряем время выполнения функций

Вот функция `time_of_function()`, которая принимает на вход любую функцию, запускает её и фиксирует время выполнения.


```
import time


# Функция time_of_function() примет на вход
# любую другую функцию и засечёт время её выполнения.
def time_of_function(func):
    start_time = time.time()
    # Вызываем функцию, полученную в аргументе:
    result = func()
    execution_time = round(time.time() - start_time, 3)
    print(f'Время выполнения: {execution_time} сек.')
    # Возвращаем результат выполнения функции, полученной в аргументе:
    return result


def sleep_one_sec():
    time.sleep(1)
    return 'Функция sleep_one_sec() завершила вычисления.'


# Вызываем функцию time_of_function(), передаём в аргументе
# объект функции sleep_one_sec (без скобок!):
decorator_result = time_of_function(sleep_one_sec)

# Печатаем результат, который вернула функция time_of_function().
# Но на самом-то деле time_of_function() вернула
# результат выполнения sleep_one_sec(), вызванной внутри декоратора:
print(decorator_result)
```


Функция, которая принимает на вход другую функцию и определённым образом меняет её поведение, называют **декоратор**. В нашем примере кода декоратор — это функция `time_of_function()`.

Функцию, поведение которой изменяет декоратор, называют «декорируемой функцией»; в нашем коде декорируемая функция — это `sleep_one_sec()`.

Декоратор, который мы написали — это был «декоратор джуна». Теперь смотрите, как принято «по-взрослому» писать и использовать декораторы в Python.


```
import time


# Декоратор объявляется до декорируемой функции.
def time_of_function(func):
    # В декораторе есть вложенная функция.
    def wrapper():
        start_time = time.time()
        result = func()
        execution_time = round(time.time() - start_time, 3)
        print(f'Время выполнения: {execution_time} сек.')
        return result
    # Декоратор возвращает вызываемый объект (callable object),
    # в нашем случае - функцию.
    return wrapper


# Имя функции-декоратора (с символом @)
# ставится перед объявлением декорируемой функции.
@time_of_function
def sleep_one_sec():
    time.sleep(1)
    return 'Функция sleep_one_sec() завершила вычисления.'


# После декорирования любой вызов функции sleep_one_sec()
# будет автоматически сопровождаться измерением времени её выполнения.
sleep_one_sec()
```



Строка `@имя_декоратора` перед объявлением функции — это «синтаксический сахар», сокращённая инструкция для Python: «при вызове функции, которая объявлена ниже, передай её в декоратор, имя которого указано после символа `@`, и затем вызови ту функцию, которую вернёт декоратор».


Таким образом, при любом вызове функции `sleep_one_sec()` она будет передана в декоратор `time_of_function()`.

Конструкцию `@имя_декоратора` в Python можно применять только в том случае, если функция-декоратор соответствует определённым правилам:

- декоратор готов принять на вход исходную функцию;
- в декораторе описана вложенная функция;
- декоратор возвращает объект, который можно вызвать (_callable object_);
- декоратор объявлен до декорируемой функции.


### В декораторе описана вложенная функция

В функции-декораторе должна быть объявлена вложенная функция (обычно её называют `wrapper()`). В этой вложенной функции описывают все действия, которые требуется выполнить дополнительно к действиям исходной функции.

Именно внутри `wrapper()` обычно выполняют вызов и самой декорируемой функции.

В нашем примере перед вызовом исходной функции и после него добавляется код для отсечки времени.


### Декоратор возвращает callable object

Когда где-то в коде вызывается функция, перед которой стоит инструкция `@имя_декоратора`, Python, фактически, подменяет исходную (вызванную) функцию на другую, объявленную внутри декоратора — и вызывает эту «подменную» функцию.

В приведённом коде вызвана функция `sleep_one_sec()` с декоратором `@time_of_function`, но «под капотом» Python произошло вот что:

1. Python видит инструкцию `@time_of_function` и вызывает функцию_-_декоратор `time_of_function()`, передавая в неё аргументом функцию `sleep_one_sec`.
2. Декоратор `time_of_function()` создаёт и возвращает собственную функцию `wrapper`. Когда эта функция будет вызвана — внутри неё запустится и декорируемая функция, и добавленный код.
3. Python вызывает функцию `wrapper()`.
4. Функция `wrapper()` фиксирует текущее время, затем вызывает оригинальную функцию `sleep_one_sec()`, и после выполнения функции снова фиксирует время и вычисляет, сколько времени заняло выполнение.


Таким образом исходная функция (callable object) `sleep_one_sec()` была подменена на другую — расширенную и изменённую функцию `wrapper()` (тоже callable object).

Функция-декоратор должна возвращать объект того же типа, который принимает на вход — функцию. Что вошло — то и вышло.

Функция должна быть вызвана — и функция вызвана. Произошла подмена, но никто ничего не заметил!


![[Pasted image 20250330172600.png]]


### Декоратор должен быть объявлен до декорируемой функции

Интерпретатор Python читает исходный код программы последовательно, сверху вниз, и к тому моменту, когда он обнаружит задекорированную функцию (например, декоратором `@my_decorator`), Python уже должен знать, что такое `my_decorator`.

Если же функция `my_decorator()` ещё не была определена в коде, Python выдаст ошибку `NameError`: «я не знаю, что такое `my_decorator`!».

Декоратор может быть определен и в импортируемом модуле; при импортировании модуля всё его содержимое, включая функции-декораторы, становится доступным в точке импорта (как правило — в начале файла).

Таким образом, если в файле есть такой код:


```
@my_decorator 
def some_function(): 
    pass 
```

_…_то функция `my_decorator` должна быть определена где-то выше в этом же файле:


```
# Объявление декоратора:
def my_decorator(func): 
    def wrapper():
        result = func()
        return result
    return wrapper

# Применение декоратора:
@my_decorator 
def some_function(): 
    pass 
```

…или импортироваться из другого файла или модуля:


```
from my_decorators import my_decorator 

@my_decorator
def some_function():
    pass 
```



## Готовые декораторы

Декораторы в Python можно написать самостоятельно, а можно применить готовые, предоставленные внешними библиотеками и модулями.

Например, декоратор `@lru_cache` из библиотеки **functools** кеширует результаты работы функции — сохраняет их для повторного применения.

Если в ходе работы программы функция вызывается повторно с теми же аргументами, с которыми уже была однажды вызвана, вычисления в функции не проводятся, а сразу возвращается закешированный результат, сохранённый с прошлого вызова.



Пример декоратора с *args **kwargs:

```python
def answer(func):

    def wrapper(*args, **kwargs):

        answ = func(*args, **kwargs)

  

        return f'Результат функции: {answ}'

    return wrapper
```
Декорируемая функция может принимать любые параметры