[[Рекурсия. Генераторы]]
Итерируемым называют объект, который содержит элементы, и эти элементы можно перебрать. Каждый шаг перебора — это итерация.

В Python итерируемые объекты — это, например, списки, кортежи, строки.

Чтобы проверить, итерируется объект или нет, можно применить к нему функцию `iter()`. Для итерируемых объектов она вернёт **объект итератора**, а для неитерируемых — ошибку _object is not iterable_.


Любой **итерируемый объект** содержит метод `__iter__()`:

```
english_words = ['apple', 'banana', 'cherry', 'date', 'fig']
# У объекта english_words есть метод __iter__?
print('__iter__' in dir(english_words))
```

```
Результат

True
```


И у любого **объекта итератора** есть метод `__next__()`, который обеспечивает обращение к следующему элементу итерируемого объекта:


```
english_words = ['apple', 'banana', 'cherry', 'date', 'fig']

# "Положить" в переменную 'a' объект итератора.
a = iter(english_words)

# У объекта итератора, который "лежит" в переменной 'а',
# есть метод '__next__'?
print('__next__' in dir(a))

# Обратиться к одному элементу итерируемого объекта...
print(a.__next__())

# Обратиться к следующему элементу итерируемого объекта.
print(a.__next__())
```

Если вы создадите объект, у которого будут методы `__iter__()` и `__next__()`, то создадите итерируемый объект — проще говоря, итератор. Только нужно учесть ещё кое-что. Например, когда в итераторе заканчиваются элементы для перебора, нужно выбрасывать исключение `StopIteration`.

Так же вам может понадобиться собственный итератор. Как вариант, когда нужно будет реализовать собственную логику перебора элементов, которая отличается от стандартной. Попробуем написать свой аналог встроенной в Python функции `range()`.


```
class MyRange:
    def __init__(self, start, end):
        # Установить начальное значение последовательности. 
        self.current = start
        # Установить конечное значение последовательности.
        self.end = end
    
    # Метод, который возвращает сам объект (self) в качестве итератора.
    def __iter__(self):
        return self
    
    # Метод, который реализует логику получения следующего 
    # элемента последовательности.
    def __next__(self):
        # Если начальное значение последовательности меньше или равно 
        # конечному значению...
        if self.current <= self.end:
            # ...вернуть текущее значение...
            value = self.current
            # ...и увеличить его на 1.
            self.current += 1
            return value
        # Иначе...
        else:
            # выбросить исключение StopIteration, чтобы указать, 
            # что элементы в последовательности закончились.
            raise StopIteration


# Тут используется описанный в классе итератор: 
# создать объект класса MyRange с начальным значением 1 
# и конечным значением 5.
my_iterator = MyRange(1, 5)

# Здесь происходит итерация по объекту my_iterator:
# к каждой итерации получить значение с помощью метода __next__ 
# и это значение присвоить переменной num.
for num in my_iterator:
    print(num)
```


Такой итератор будет генерировать числа от 1 до 5 включительно.

## Что такое генератор

Генератор — это подвид итератора: функция, которая генерирует значения.

Генератор не хранит элементы в оперативной памяти, а вычисляет их по заданному правилу. Как следствие, генератор занимает в памяти очень мало места.

Генератор объявляется как обычная функция, но вместо инструкции `return` в нём используется `yield`. Инструкция `return` завершает работу функции, а `yield` лишь приостанавливает её и при этом возвращает какое-то значение.

```
# Создать функцию-генератор.

def short_sequence():
    num = 1
    while num < 5:
    # Сгенерировать значение через yield.
        yield num
        num += 1


# Здесь функция-генератор возвращает итератор.
step = short_sequence()


# Обратиться к методу __next__() итератора
# и получить первое значение последовательности.
print(step.__next__())


# Ещё раз обратиться к методу __next__()
# и получить второе значение последовательности.
print(step.__next__())
```


Логика работы кода такова:

1. При первом вызове метода `__next__()` инструкция `yield` генерирует и возвращает первое значение — `1`.
2. Затем функция-генератор встаёт на паузу на выполнении цикла `while`, запомнив своё состояние.
3. При втором вызове метода `__next__()` функция-генератор продолжает работу с того места, на котором остановилась, и возвращает следующее значение — `2`.

Когда значения исчерпаются, генератор выбросит исключение `StopIteration`.

Генератор может быть устроен по-разному; важно, чтобы значения генерировались через инструкцию `yield`.

```
def english_word_generator():
    # Сгенерировать слово.
    yield 'orange'
    
    # Проитерироваться по списку слов и вернуть каждое слово из списка.
    for word in ['apple', 'banana', 'Cherry', 'Date', 'fig']:
        yield word

    # Сгенерировать ещё одно слово.
    yield 'pineapple'

# Запустить генератор, проитерироваться по всем возвращаемым им значениям 
# и вывести каждое значение на экран.
for word in english_word_generator():
    print(word)
```


**Результат**

```
orange
apple
banana
Cherry
Date
fig
pineapple
```




##### **!!!**
Получить элемент генератора по индексу невозможно, вернётся ошибка `TypeError`.

## Что такое генераторное выражение

Генераторное выражение — это упрощённый синтаксис для создания генератора.

Очень часто генераторы могут быть записаны с использованием синтаксиса, похожего на _list comprehension_, но не в квадратных, а в круглых скобках.



```
# Так описывается список через list comprehension.
simple_list = [digit for digit in range(2)]

print(type(simple_list))
a = iter(simple_list)
print(a.__next__())
print(a.__next__())

# Выведется:
# <class 'list'>
# 0
# 1

# А так описывается генераторное выражение.
simple_generator = (digit for digit in range(2))

print(type(simple_generator))
print(simple_generator.__next__())
print(simple_generator.__next__())

# Выведется:
# <class 'generator'>
# 0
# 1
```

Генераторы требуют меньше памяти, и если нужно сформировать последовательность, то выгоднее формировать её именно через генератор или генераторное выражение, а не через _list comprehension_.

Пример генератора:
```
# Список для тестирования.
numbers = [1, 3, 4, 6, 9, 11]

# Здесь напишите ваше генераторное выражение.
generator = (i*i for i in numbers if i % 3 == 0)

# Распечатайте сумму квадратов.
print(sum(generator))
```

## В чём разница между итератором и генератором

Все генераторы — итераторы, но не все итераторы — генераторы. Итератор — более общая концепция.

Генератор хранит в памяти не элементы, а внутреннее состояние для вычисления очередного элемента. На каждом шаге можно вычислить только следующий элемент, но не предыдущий.

**!!!**
Генератор, исчерпавший все свои значения, помнит своё состояние («я всё сделал!»), поэтому повторное обращение к нему не вернёт никакого результата. Второй раз подряд проитерироваться по генератору не получится.


```
def calc_squares(start, stop):
    for i in range(start, stop):
        yield i * i

generator = calc_squares(5, 10)

# Первый перебор.
print(list(generator))
# Второй перебор. 
print(list(generator))
```

**Результат**

```
[25, 36, 49, 64, 81]
[]
```


## Что в итоге

- Итерируемым называют объект, который содержит элементы, и эти элементы можно перебрать. Каждый шаг перебора — это итерация.
- Чтобы проверить, итерируется объект или нет, можно применить к нему функцию `iter()`: для итерируемых объектов она вернёт **объект итератора**, а для неитерируемых — ошибку _object is not iterable_.
- Любой итерируемый объект содержит метод `__iter__()`, а объект итератора — метод `__next__()`.
- Чтобы создать собственный итерируемый объект, нужно для этого объекта реализовать методы `__iter__()`, `__next__()` и выброс исключения `StopIteration` на случай, если значения итератора исчерпаются.
- Генератор — это подвид итератора: функция, которая генерирует значения. Его использование помогает экономить место в оперативной памяти.
- Генератор объявляется как обычная функция, но вместо инструкции `return` в нём используется `yield`. Инструкция `return` завершает работу функции, а `yield` лишь приостанавливает её и при этом возвращает какое-то значение.
- Генератор можно перебрать в цикле только один раз.
- Генераторное выражение — это упрощённый синтаксис для создания генератора.


```
simple_generator = (digit for digit in range(2)) 
```



