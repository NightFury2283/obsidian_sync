При работе над кодом никто не застрахован от ошибок. 
Задача разработчика — минимизировать число возможных ошибок, а выявленные ошибки найти и исправить. 
Одной из причин возникновения проблем в коде может быть ошибка в типах данных. 

```

def we_crash_all(name):
    return 'Привет, ' + name + ', мы всё сломали!'


print(we_crash_all('Наташа'))
```


Хорошая функция, отлично работает, никаких проблем.

Но никто не мешает передать в функцию `we_crash_all()` булеву переменную (разработчик вполне может не учесть возможность такого события)

## Type Hints: аннотация типов данных

Чтобы держать типизацию под контролем, применяют **аннотации типов данных** (_type hints_, дословный перевод с английского — «подсказки по типам»). Это явное указание типа ожидаемых данных при объявлении переменных, классов и функций.


```
# Без аннотации: объявили переменную, 
# а Python сам определил, какой в ней тип данных.
birth_year = 1971

# С аннотацией: объявили переменную и указали, 
# что это переменная только для целых чисел.
birth_year: int = 1971

# Общий синтаксис аннотирования переменных:
<имя переменной>: <принимаемый тип> = <значение> 
```

При выполнении кода Python **игнорирует аннотации** типов и не выдаёт ошибок, даже если типизация нарушена:


```
# Переменная var_for_bool аннотирована как булева, но в неё передана строка.
var_for_bool: bool = 'Чистая правда, клянусь!' 
```

Python не обратит внимания на это несоответствие и продолжит выполнять код как ни в чём не бывало. Аннотация будет проигнорирована, переменная будет воспринята Python как строка.

Однако Python не оставляет аннотации типов совсем без внимания: он считывает их и сохраняет в словарь `__annotations__`.

Содержимое этого словаря можно вывести на экран:

```
# Аннотация переменной name: "это строка".
name: str = 'Наташа'

# Аннотация переменной var_for_bool: "это булева переменная".
var_for_bool: bool = True

# Можно напечатать аннотации переменных:
print(__annotations__)
```

```
{'name': <class 'str'>, 'var_for_bool': <class 'bool'>}
```

Этот словарь может быть считан и проанализирован сторонними программами, которые специализируются на проверке типизации. Если такая программа-анализатор обнаружит несоответствие, например, типа аргумента, переданного в функцию, и типа, который ожидает функция, то программа уведомит об этом разработчика.

По смыслу работа такой программы похожа на работу линтера, её задача — проверить код и предупредить разработчика, если он пишет что-то не то.

Существует несколько популярных инструментов для проверки типизации:

- [Mypy](http://mypy-lang.org/) — активно развивается при участии Гвидо ван Россума, создателя Python. Это один из наиболее известных инструментов для работы с аннотациями типов в Python.
- [Pyre](https://pyre-check.org/) — отличная альтернатива Mypy.
- [Pytype](http://github.com/google/pytype) — инструмент для анализа типов, разработанный компанией Google.
- [Mypy Type Checker](https://marketplace.visualstudio.com/items?itemName=ms-python.mypy-type-checker) — создан корпорацией Microsoft.

### Type Hints для переменных

Переменные в Python обычно аннотируются так:

```
# Только целочисленные значения.
var_integer: int = 10
# Числа с плавающей точкой (включая целые, можно передать и значение 10).
var_float: float = 10.0
# Логический тип.
var_flag: bool = True
# Строки.
var_string: str = 'я строка'
```

### Type Hints для функций

Для функций тоже можно указывать аннотации, например для аргументов и возвращаемого значения:

```
# def <имя функции>(<аргумент>: <тип>) -> <возвращаемый тип>:

def is_rhomb(a_size: float, b_size: float) -> bool:
    """Принимает на вход длины сторон параллелограмма
       и проверяет, является ли параллелограмм ромбом."""
    # Вернёт True или False в зависимости от истинности выражения.
    return a_size == b_size


# Функция print_hi() ожидает строковый аргумент name,
# значение этого аргумента по умолчанию - 'незнакомец'.
# Функция ничего не возвращает, тип возвращаемых данных - None.
def print_hi(name: str = 'незнакомец') -> None:
    print('Привет,' + name + '!')


# Можно напечатать аннотации функций:
print(f'Аннотации для is_rhomb(): {is_rhomb.__annotations__}')

print(f'Аннотации для print_hi(): {print_hi.__annotations__}')
```

### Когда встроенных типов недостаточно

Иногда возникают ситуации, когда переменная может быть либо конкретного типа, либо `None`. В аннотации необходимо указать одновременно два типа данных.

В таких ситуациях на помощь приходит модуль **typing**.

Модуль `typing` в Python предоставляет набор стандартных типов и инструментов для создания более сложных аннотаций.

Рассмотрим некоторые из них:

**Optional.** Используется, когда аргумент функции может быть определённым типом или `None`. Например, если переменная `any_var` может принять целое число или `None`, надо аннотировать её так: `any_var: Optional[int]`. Значение `None` не нужно указывать явным образом.

Например, функция может вернуть данные разного типа, и переменная должна быть аннотирована обоими этими типами:

```
# Для применения модуля typing нужно импортировать или весь модуль,
# или необходимые типы из него.
from typing import Optional


def greet(name: Optional[str] = 'гость'):
    if not name == 'гость':
    # Если в переменную name передана какая-то строка -
    # функция вернёт приветственную фразу:
        return f'Привет, {name}!'
    # Если же в переменную name ничего не передано 
    # и она приняла значение по умолчанию - функция вернёт Nоne.


# Функция greet() может вернуть строку или None,
# так что надо аннотировать переменную этими двумя типами.
result_no_name: Optional[str] = greet()
print(result_no_name)

result_has_name: Optional[str] = greet('Гвидо')
print(result_has_name)
```


**Union.** Этот тип используется, когда переменная может получить значение одного из нескольких типов.

```
from typing import Union


# Функция будет успешно работать как с целыми числами,
# так и с десятичными дробями:
def is_rhomb(a_size: Union[int, float], b_size: Union[int, float]) -> bool:
    """Принимает на вход длины сторон параллелограмма
       и проверяет, является ли параллелограмм ромбом."""
    # Вернёт True или False в зависимости от истинности выражения.
    return a_size == b_size


def greet(name='гость'):
    if not name == 'гость':
        return f'Привет, {name}!'


# Переменную, которая готова принять значения типа None и str,
# можно аннотировать и с помощью Union:
result_has_name: Union[str, None] = greet('Гвидо')
```

[документации](https://docs.python.org/3.9/library/typing.html#special-typing-primitives)

