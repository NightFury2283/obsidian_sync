
**Пространство имён** — это среда, в которой каждое имя (например, имя переменной, функции или класса) сопоставляется с уникальным объектом. Другими словами, пространство имён — это своего рода словарь, где ключами являются имена переменных, а значениями — объекты, на которые эти имена ссылаются.

В Python существуют различные пространства имён:

- встроенное (built-in),
- глобальное (global),
- локальное (local).


### Встроенное пространство имён

Встроенное пространство имён содержит имена всех **встроенных** объектов, которые доступны при работе в Python. Получить список всех объектов во встроенном пространстве можно при помощи команды `dir(__builtins__)`.


Этот список содержит все функции и объекты, которые доступны в Python «из коробки».

Встроенное пространство имён создаётся при запуске интерпретатора Python и сохраняется до тех пор, пока интерпретатор не завершит работу.


### Глобальное пространство имён

Глобальное пространство содержит имена, определённые на уровне модуля.

```
# Определяем переменную value в глобальном пространстве имён.
value = 'Я в глобальном пространстве имён!'


def inner_function():
    value = 'А я нет!' 
```


Глобальное пространство имён создаётся при запуске программы и сохраняется до момента завершения работы интерпретатора.

Интерпретатор создаёт глобальное пространство имён и для любого модуля, загружаемого программой при помощи команды `import`.


### Локальное пространство имён

При каждом вызове функции или метода, при каждом выполнении спискового или словарного включения, при работе с менеджерами контекста и в других подобных ситуациях Python создаёт новое пространство имён. Это **локальное пространство имён**, оно сохраняется, пока соответствующая конструкция выполняет свою работу.

Если объявить одну функцию внутри другой, то при вызове этих функций у внешней функции будет своё локальное пространство имён, а у вложенной — своё. Имя вложенной функции будет принадлежать пространству имён внешней функции.


```
def outer_function():
    print('Старт функции outer_function()')

    def inner_function():
        print('Старт функции inner_function()')
        print('Завершение функции inner_function()')

    inner_function()
    print('Завершение функции outer_function()')


outer_function()
```


Когда основная программа вызывает функцию `outer_function()`, Python создаёт локальное пространство имён этой функции.

Когда в `outer_function()` вызывается вложенная `inner_function()`, `inner_function()` тоже получает своё собственное, отдельное пространство имён.

Эти локальные пространства существуют до тех пор, пока выполняются соответствующие им функции. По завершении работы этих функций Python может не сразу удалить пространства имён из памяти, но все ссылки на содержащиеся в них объекты станут недоступны немедленно.


### Области видимости переменной

В разных пространствах имён могут одновременно существовать несколько разных переменных с одинаковыми именами. Пока каждая из них находится в собственном пространстве, все они обслуживаются по отдельности, и путаницы не происходит. Чтобы обратиться к нужной, применяется концепция «области видимости переменной».

**Области видимости** определяют, какие пространства имён доступны для поиска нужного имени.

Область видимости определяется местом в коде, из которого запрошено имя. Область видимости может быть локальной, охватывающей, глобальной или встроенной.


#### **Локальная область видимости.** 
Если сослаться на какую-то переменную, то интерпретатор сначала будет искать её в локальном пространстве имён, которое относится к текущему функциональному блоку.


```
 value = 'Глобальная value'
 
 
 def outer_function():
     value = 'Локальная value из outer_function()'
 
     ...
 
     def inner_function():
         value = 'Локальная value из inner_function()'
         print(value)  # Обратились к переменной value.
         # Сперва ищем это имя в локальном пространстве имён,
         # внутри функции inner_function(). Нашли! Печатаем.
 
     inner_function()
 
     
 outer_function()
 
 # Будет напечатано:
 # Локальная value из inner_function()
 
```


**Внешняя (охватывающая) область видимости.** Если запрошена переменная, которой нет в локальном пространстве имён, поиск продолжается в охватывающем пространстве.


```
 value = 'Глобальная value'
 
 
 def outer_function():
     value = 'Локальная value из outer_function()'
 
     ...
 
     def inner_function():
         # value = 'Локальная value из inner_function()'
         print(value)  # Обратились к переменной value.
         # Ищем это имя в локальном пространстве имён - нету!
         # Ищем в ближайшем внешнем пространстве имён,
         # в локальном пространстве функции outer_function(). Нашли! Печатаем.
 
     inner_function()
 
     
 outer_function()
 
 # Будет напечатано:
 # Локальная value из outer_function()
 
```



**Глобальная область видимости.** Если имя не найдено и в охватывающих пространствах имён, интерпретатор начнёт искать его в глобальной области видимости — в глобальном пространстве, которое обычно соответствует уровню модуля.


```
 value = 'Глобальная value'
 
 
 def outer_function():
     # value = 'Локальная value из outer_function()'
 
     ...
 
     def inner_function():
         # value = 'Локальная value из inner_function()'
         print(value)  # Обратились к переменной value.
         # Ищем это имя в локальном пространстве имён - нету!
         # Ищем в ближайшем внешнем пространстве имён - нету!
         # Ищем в глобальном пространстве имён. Нашли! Печатаем.
 
     inner_function()
 
     
 outer_function()
 
 # Будет напечатано:
 # Глобальная value
 
```


4. **Встроенная.** Если интерпретатор так и не нашёл переменную, он продолжит поиск во встроенном пространстве имён.
    

Если интерпретатор не найдёт имя и во встроенном пространстве имён, будет вызвано исключение `NameError`.


Эта последовательность поиска реализует **правила областей видимости LEGB** (**L**ocal, **E**nclosing, **G**lobal, **B**uilt-in). Поиск имени происходит в пространствах имён, но какие именно пространства имён будут проверены — зависит от текущей области видимости в соответствии с правилом LEGB.


### Инструкция global

В любом локальном пространстве вы можете определить переменную как глобальную — для этого есть инструкция `global`.

```
my_var = 10


def my_function():
    # Описываем переменную как глобальную...
    global my_var
    # Теперь глобальную переменную можно обрабатывать прямо внутри функции,
    # например - переопределить:
    my_var = 5
    print('Внутри функции:', my_var)
    # ...и снова переопределить:
    my_var += 95
    print('Внутри функции после изменений:', my_var)


my_function()
print('Снаружи функции:', my_var)
```


Теперь переменная `my_var` в теле функции `my_function()` будет ссылаться на глобальную переменную `my_var`. Следовательно, выражение `my_var = 5` не создаст новую переменную в локальном пространстве имён, а присвоит новое значение переменной `my_var` в глобальном пространстве имён.

Если же при запуске функции не существует глобальной переменной с именем, определённом в объявлении `global`, то инструкция `global` и операция присваивания создадут эту переменную в глобальном пространстве имён.

Обратиться к переменной, определённой через `global`, можно только после того, как она определена. Если же сначала обратиться к переменной, а потом объявить её глобальной, возникнет коллизия, и Python выбросит исключение:


### Инструкция nonlocal

Global – отличная инструкция. Но она не поможет, если у вас есть функция, вложенная в другую, и нужно из вложенной функции управлять переменной во внешней функции. Вот посмотрите:

```
def outer_function():
    value = 10  # Как из вложенной функции добраться до этой переменной?

    def inner_function():
        # Попытка изменить переменную, объявленную в outer_function()...
        value = 20

    inner_function()
    print(value)  # ...ни к чему не приводит.

    
outer_function()

# Будет напечатано: 10
```


В этом примере переменная `value` со значением `10` определена в локальном пространстве имён функции `outer_function()`. По отношению к функции `inner_function()` **это внешняя** область, и это не глобальное пространство имён.

Инструкция `global` не поможет «дотянуться» из тела функции `inner_function()` до переменной, объявленной в `outer_function()`:

**!!!**
Обратиться к имени во внешней области можно при помощи ключевого слова `nonlocal`. Переменные, определённые после `nonlocal`, ссылаются на переменные в пространстве имён **в ближайшей внешней области** видимости.


```
def outer_function():
    value = 10

    def inner_function():
        nonlocal value
        value = 20

    inner_function()
    print(value)

    
outer_function()

# Будет напечатано: 20
```


### Словари пространств имён Python

В Python есть специальные словари, которые хранят информацию о глобальном и локальном пространствах имён.

Получить доступ к этим словарям можно через встроенные функции `globals()` и `locals()`.


```
global_value = 10


def any_function():
    local_value = 20
    local_text = 'Локальная строка'
    global global_value
    global_value = 100500  # Изменяем глобальную переменную.
    # Печатаем словарь с объектами локального пространства функции:
    print(f'Локальные переменные в функции any_function(): {locals()}')


any_function()

# Печатаем словарь с объектами глобального пространства программы:
print(f'Глобальные переменные программы: {globals()}')
```


```
Локальные переменные в функции any_function(): {'local_value': 20, 'local_text': 'Локальная строка'}


Глобальные переменные программы: {'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': <_frozen_importlib_external.SourceFileLoader object at 0x7f60187afc10>, '__spec__': None, '__annotations__': {}, '__builtins__': <module 'builtins' (built-in)>, '__file__': '/home/student/runner.py'...
```


Переменная `value` объявлена, передаётся в функции и обрабатывается в нескольких местах кода. В трёх местах кода значение этой переменной выводится на печать.

Определите, что будет напечатано при запуске этой программы.

- к переменной в глобальном пространстве можно обратиться посредством инструкции `global`;
- к переменной в ближайшем охватывающем пространстве можно обратиться посредством инструкции `nonlocal`.


[[Python]]