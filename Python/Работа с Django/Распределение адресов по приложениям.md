

В каждом приложении можно создать собственный файл _urls.py_ и в нём перечислить адреса, обрабатываемые именно этим приложением, а в корневом _urls.py_ нужно лишь указать ссылки на эти файлы.


```
acme_project/       <-- Рабочая папка Django-проекта
 ├── acme_project/   <-- Папка с настройками проекта  
 |   ├── ...
 |   ├── urls.py     <-- Корневой файл urls.py, к нему подключаются urls приложений  
 |   └── ...
 ├── catalog/        <-- Папка приложения catalog
 |   ├── ...
 |   ├── urls.py     < -- Файл urls.py с адресами приложения catalog
 |   └── ...
 ├── homepage/       <-- Папка приложения homepage
 |   ├── ...
 |   ├── urls.py     < -- Файл urls.py с адресами приложения homepage
 |   └── ...
 ... 
```


Чтобы сослаться из корневого _urls.py_ на файлы _urls.py_ приложений, применяют функцию `include()` (англ. «включить», «встроить»); её указывают вторым аргументом в `path()`, вместо имени view-функции:


```python
# Корневой файл urls.py 

# Импортируем встроенные функции include() и path().
from django.urls import include, path

urlpatterns = [    
    # Если на сервер пришёл запрос к главной странице,
    # Django проверит на совпадение с запрошенным URL 
    # все path() в файле urls.py приложения homepage.
    path('', include('homepage.urls')),

    # Если в приложении homepage не найдётся совпадений,
    # Django продолжит искать совпадения здесь, в корневом файле urls.py.

    # Если запрос начинается с catalog/, 
    # Django будет искать совпадения в файле urls.py
    # приложения catalog.
    path('catalog/', include('catalog.urls')),
] 
```


Остальные приложения обрабатывают адреса, которые пришли в корневой urls.py:

```python
# catalog/urls.py
from django.urls import path

from . import views

urlpatterns = [
    # Если пришёл запрос к относительному URL catalog/,
    # то запрос из корневого urls.py перенаправляется сюда, 
    # в файл catalog/urls.py;
    # и если в запросе после 'catalog/' ничего нет (пустая строка),
    # будет вызвана view-функция product_list() из файла catalog/views.py
    path('', views.product_list),

    # Если в запросе после 'catalog/' стоит '1/' или '2/',
    # будет вызвана view-функция product_detail() из файла catalog/views.py
    path('1/', views.product_detail),
    path('2/', views.product_detail),
]
```


При `include` URL будто режется на две части: часть адреса указывается в корневом _urls.py_, а оставшаяся часть — в том _urls.py_, на который ссылается `path()` из корневого файла.

Например, при запросе к URL _catalog/1/_ в корневом файле _urls.py_ сработает путь

`path('catalog/', include('catalog.urls'))`,

а в файле _catalog/urls.py_ Django будет искать шаблон, который соответствует адресу _1/_, то есть такой:

`path('1/', views.product_detail)`, без строки `catalog/`.

В начале маршрутов не нужно добавлять слеш (символ `/`): он есть в корневом _urls._ Кстати, не забывай импортировать в код функцию `path()`, view-функции и функцию `include()` в корневой _urls.py_. Без импорта ничего не заработает.

Отдельное приложение для главной страницы — **homepage** — создавать не обязательно. Запросы к главной странице можно обрабатывать в приложении **catalog**.

Но проект может вырасти: на главную страницу добавятся новости, отзывы — и без приложения homepage будет непонятно, куда разместить файлы, отвечающие за работу главной страницы. Чтобы избежать путаницы в файловой структуре, лучше заранее создать отдельное приложение для управления этой страницей. Если не пригодится — ничего страшного, а если потребуется — вот оно, готово.


