
Надо защитить проект и записи добропорядочных пользователей от безответственной сетевой публики. Классическим решением для этой задачи служит **авторизация пользователей**.

Если настроить авторизацию, то можно будет:

- разрешить публиковать новые записи только зарегистрированным пользователям;
- разрешить редактировать записи только тем пользователям, которые их опубликовали;
- настроить и другие права доступа, если потребуется.

Встроенная система работы с пользователями — это одно из основных преимуществ фреймворка Django. Эта система доступна сразу при развёртывании Django-проекта и позволяет быстро решать задачи **аутентификации** и **авторизации** пользователей.

**Аутентификация** — это проверка, что пользователь действительно тот, за кого он себя выдаёт (например, при аутентификации можно сравнить пароль, введённый пользователем, с паролем, сохранённым в БД при регистрации пользователя).

**Авторизация** — это проверка, имеет ли право определённый пользователь выполнять те или иные действия на сайте (в том числе — получать доступ к тем или иным страницам).

Чтобы разобраться в этих формулировках, представим, как зарегистрированный пользователь с логином _Yellow_duck_ пользуется проектом **acme_project**.

Первым делом он **аутентифицируется**: вводит в форму свой логин и пароль. Пара логин-пароль передаётся на сервер и сверяется с БД. Если в БД найден такой логин и соответствующий ему пароль — пользователь прошёл аутентификацию.

Дальше пользователь пытается войти в админ-зону, на страницу _admin/_. В этот момент срабатывает **авторизация**: система проверяет, имеет ли пользователь _Yellow_duck_ право доступа к странице администрирования. Предположим, что этот пользователь не наделён правами администратора; значит, он не пройдёт авторизацию для страницы _admin/_: ему вернётся ошибка 403, «недостаточно прав для просмотра страницы». А вот авторизацию для просмотра страницы _birthday/list/_ он получит: она доступна всем пользователям.


## Модуль django.contrib.auth

Работа с пользователями в Django обеспечивается взаимодействием нескольких компонентов — модулей и промежуточных слоёв (middlewares), по умолчанию подключённых к проекту.

«Ядро» системы работы с пользователями — это встроенный модуль `django.contrib.auth`, именно его мы и будем изучать в этом и ближайших уроках.

Модуль `django.contrib.auth` автоматически подключается при развёртывании Django-проекта. Этот модуль исходно добавлен в список подключённых приложений `INSTALLED_APPS` в _settings.py_:


```python
# acme_project/settings.py
...

INSTALLED_APPS = [
    ...,
    'django.contrib.admin',
    'django.contrib.auth',   # Приложение для работы с пользователями.
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    ...,
]
```


Модуль `django.contrib.auth` прямо «из коробки» готов к работе: в нём есть свои модели, свой _urls.py_ и _views.py_, набор HTML-шаблонов для отображения страниц с формами.

К основным возможностям модуля относятся:

- логин (вход в систему) и логаут (выход из системы) пользователей,
- смена и сброс пароля,
- управление пользователями,
- проверка прав доступа пользователей.

Помимо `django.contrib.auth`, для работы с пользователями применяются и другие модули; узнать о них подробнее можно [в документации](https://docs.djangoproject.com/en/3.2/topics/auth/#installation).

## Модель пользователя

Сразу после развёртывания Django и применения встроенных миграций в проекте становится доступна модель пользователя `User` с готовым набором полей:

- username
- password
- email
- first_name
- last_name
- groups
- user_permissions
- is_staff
- is_active
- is_superuser
- last_login
- date_joined

Ничего магического в модели пользователя нет — это просто модель, объекты которой соответствуют записям в базе данных. При регистрации нового пользователя создаётся новый объект этой модели; редактирование, удаление объектов — всё происходит так же, как и в других моделях.

Подробное описание полей модели `User` есть [в документации](https://docs.djangoproject.com/en/3.2/ref/contrib/auth/#django.contrib.auth.models.User); часть из них мы рассмотрим повнимательнее.

Самое время запустить проект и аутентифицироваться под логином суперпользователя. Если вдруг суперпользователь не создан или потерялся пароль — можно создать нового через консоль:


```bash
python manage.py createsuperuser
```


Зайдите под логином суперпользователя в админ-зону и в разделе «Пользователи» кликните по своему логину. На странице управления аккаунтом будут видны все поля стандартной модели `User`.


![[Pasted image 20250527214013.png]]


## Права пользователей и группы

Помимо модели пользователя, модуль `django.contrib.auth` содержит модели, описывающие права пользователей и группы.


![[Pasted image 20250527214054.png]]


Права (_permissions_, это слово можно перевести и как «разрешения» или «полномочия») — определяют, какие действия разрешено выполнять тому или иному пользователю.

С технической точки зрения права пользователя сводятся к перечню операций, которые он может выполнять при управлении той или иной моделью проекта: может ли он просмотреть объект, создать, отредактировать или удалить его.

Набор из этих четырёх прав автоматически создаётся для каждой модели; в админ-зоне можно указать, какими из перечисленных прав обладает каждый пользователь, зарегистрированный на сайте.

На скриншоте — фрагмент страницы настроек определённого пользователя; видно, что из всех прав, которые возможны, администратор проекта разрешил пользователю управлять только моделью `Birthday`, да и то не полностью: удалять объекты он не может.


Назначать права каждому отдельному пользователю — утомительное дело; чтобы упростить администрирование, придумали **группы пользователей**.

Группам можно назначать права, а затем привязывать пользователей к той или иной группе; права группы автоматически распространяются на всех пользователей группы.

Распределение пользователей по группам можно использовать не только для определения прав, но и в другой логике приложения — например, при рассылке писем можно отправлять пользователям отличающиеся сообщения в зависимости от того, какой группе принадлежит пользователь.

Особое место среди пользователей занимает Суперпользователь (_superuser_). Это не группа, а просто «статус»: пользователь, у которого в поле `is_superuser` установлено значение `True`, автоматически получает все возможные права — хотя явно они могут быть и не присвоены.

Загляните на страницу настроек суперпользователя в своём проекте: в поле «Выбранные права пользователя» пусто, однако суперпользователь может создавать, редактировать и удалять любые объекты через админку.


Поле «Статус персонала» `is_staff` определяет, есть ли у пользователя право входить в админку. Казус в том, что если у суперпользователя снять галочку `is_staff`, то у него останутся все права, но в админку он попасть уже не сможет.

Создайте через админку нового пользователя (не суперюзера) и дайте ему право входить в админку — поставьте галочку «Статус персонала»; не давайте ему больше никаких прав.

Зайти в админку под логином этого пользователя получится, но никаких действий с моделями выполнить не удастся:


Через аккаунт суперпользователя добавьте пользователю право просматривать объекты модели `Birthday` (фильтр в верхней части списка с правами поможет найти нужные права):


![[Pasted image 20250527214342.png]]


Теперь этот пользователь сможет просматривать в админке объекты модели `Birthday` (при условии, что эта модель зарегистрирована в админке); изменить или удалить эти объекты пользователь не сможет.

## Права доступа к страницам проекта

Необычность ситуации состоит в том, что зарегистрированный пользователь с правом доступа в админку не может через админку создать, удалить или отредактировать объекты `Birthday`, тогда как даже анонимный пользователь может делать с этими объектами всё, что захочет, если войдёт на сайт с «пользовательской» стороны — на страницы _birthday/_, _birthday/<pk>/edit/_ или _birthday/<pk>/delete/_.

Дело в том, что в админке проверка прав доступа настроена изначально, а для пользовательских страниц эту проверку мы ещё не настраивали.

Авторизация доступа к страницам настраивается во view-классах и view-функциях: перед тем как сгенерировать ответ — представление проверяет, какие права есть у пользователя, запросившего страницу, и по результатам проверки либо возвращает запрошенную страницу, либо страницу с ошибкой 403 — «недостаточно прав».


## Изменение модели пользователя

В проекте может потребоваться профиль пользователя, в котором есть биография, дата рождения, должность или фотография; стандартной модели пользователя для этого будет недостаточно: необходимо добавить в модель дополнительные поля.

Но нельзя просто взять и отредактировать модель `User`: код фреймворка менять нельзя. Нужен другой путь.

Справиться с этой задачей можно двумя способами:

1. Расширить модель пользователя.
2. Заменить модель пользователя.

## Расширение модели пользователя


![[Pasted image 20250527214512.png]]


Для расширения модели пользователя создают дополнительную модель, в которую добавляют поля, которых не хватает в основной модели пользователя. Эту модель связывают с основной моделью пользователя через связь «один-к-одному».


![[Pasted image 20250527214535.png]]


У этого способа есть недостатки:

- нагрузка на БД повысится, ведь для получения дополнительных полей придётся отправлять запросы с JOIN; запросы к связанной модели нужно будет оптимизировать;
- придётся дополнительно настроить админку так, чтобы поля основной и дополнительной моделей отображались на одной странице, а не были разбросаны по разным разделам;
- нужно будет описать автоматическое создание объекта кастомной модели при создании объекта в «главной» модели пользователя.

Однако этот подход хорош тем, что его можно применить в любой момент, даже если проект уже разрабатывается, а база данных наполнена.

Подробнее о расширении модели пользователя можно почитать [в документации](https://docs.djangoproject.com/en/3.2/topics/auth/customizing/#extending-the-existing-user-model).

## Замена модели пользователя


![[Pasted image 20250527214639.png]]


Стандартная модель пользователя `User`, которая по умолчанию применяется в Django, унаследована от модели `AbstractUser` из модуля `django.contrib.auth.models`.

`AbstractUser` — это абстрактный класс, полная модель пользователя со всеми необходимыми полями.

Можно создать собственную модель пользователя, унаследовав её от `AbstractUser`, и добавить в модель-наследник необходимые дополнительные поля.

В дальнейшем собственную модель пользователя можно будет расширять и как угодно изменять: управление этой моделью будет полностью в руках разработчика. А про стандартную модель `User` можно будет просто забыть.

Однако при таком подходе есть определённые ограничения: заменять модель пользователя рекомендуется на самом старте проекта, до выполнения встроенных миграций.

Если попробовать заменить модель пользователя уже после применения встроенных миграций, то возникнут ошибки при выполнении пользовательских миграций: существующие в БД таблицы ссылаются на другую (встроенную) модель пользователя, и автоматически разрешить этот конфликт нельзя.

Есть и радикальный способ, он сработает даже в том случае, если БД наполнена: создать собственную модель пользователя, удалить базу данных, а затем создать и выполнить миграции. Разумеется, при таком подходе без дополнительных усилий не удастся сохранить данные в БД.


Самый простой вариант замены пользовательской модели при старте проекта выполняется в три шага:

1. Создать кастомную модель пользователя, унаследовав её от `AbstractUser`.
2. Указать ссылку на кастомную модель в константе `AUTH_USER_MODEL` в настройках проекта.
3. Зарегистрировать новую модель в админке.

Для моделей и других сущностей, управляющих пользователями, можно создать собственное приложение. Но это не догма, модель пользователя может храниться где-то ещё, по выбору разработчика.

Разберём на примере, как заменить встроенную модель пользователя на кастомную и добавить в неё дополнительное поле — пусть это будет поле «биография».


Файлы, относящиеся к управлению пользователями, принято хранить в отдельном приложении; традиционно его называют **users**.

Первым делом создаётся и регистрируется приложение **users**, а в нём описывается новый класс — кастомная модель пользователя; этот класс следует создать в самом начале работы над проектом, до того, как будут выполнены встроенные миграции.

В новую модель пользователя сразу добавим поле `bio`.


```python
# users/models.py
from django.contrib.auth.models import AbstractUser
from django.db import models


class MyUser(AbstractUser):
    bio = models.TextField('Биография', blank=True)
```


Теперь нужно внести правки в _settings.py_: здесь надо указать, что вместо стандартной модели пользователя будет использоваться кастомная модель (в нашем случае — из приложения **users**).


```python
# settings.py
...
AUTH_USER_MODEL = 'users.MyUser'
```


После этого надо создать и применить миграции.

Модель пользователя нужно зарегистрировать в админке, иначе управлять пользователями через админку будет невозможно.

Чтобы поле с биографией отображалось в форме для редактирования пользователя, надо расширить атрибут `fieldsets` (набор полей) класса `UserAdmin`.


```python
# users/admin.py
from django.contrib import admin
from django.contrib.auth.admin import UserAdmin

from .models import MyUser

# Добавляем поле с биографией 
# к стандартному набору полей (fieldsets) пользователя в админке.
UserAdmin.fieldsets += (
    # Добавляем кортеж, где первый элемент — это название раздела в админке,
    # а второй элемент — словарь, где под ключом fields можно указать нужные поля.
    ('Extra Fields', {'fields': ('bio',)}),
)
# Регистрируем модель в админке:
admin.site.register(MyUser, UserAdmin)
```


В админке появится дополнительный раздел Extra Fields, а в нём — текстовое поле для биографии:


![[Pasted image 20250527215140.png]]


Более подробно про атрибут `fieldsets` можно почитать [в документации](https://docs.djangoproject.com/en/3.2/ref/contrib/admin/#django.contrib.admin.ModelAdmin.fieldsets).

В случае, если новые поля в модели не нужны, но разработчик решил последовать рекомендациям Django и создать собственную модель пользователя — можно создать пустой класс, унаследованный от `AbstractUser`:


```python
from django.contrib.auth.models import AbstractUser


class MyUser(AbstractUser):
    pass
```


Эта модель точно так же должна быть указана в _settings.py_ в константе `AUTH_USER_MODEL`. А при добавлении модели в админку нет необходимости указывать новые поля:


```python
# users/admin.py
from django.contrib import admin
from django.contrib.auth.admin import UserAdmin

from .models import MyUser 

# Не добавляем поля через UserAdmin.fieldsets,
# а сразу регистрируем модель в админке:
admin.site.register(MyUser, UserAdmin)
```


Если в какой-то момент развития проекта потребуется добавить новые поля в модель пользователя — нужно будет:

- добавить поля в собственный класс пользователя;
- создать и выполнить миграции;
- через `UserAdmin.fieldsets` вывести новые поля пользователя в админ-зону.

## Как обратиться к модели пользователя

В Django-проекте модель пользователя по умолчанию называется **User**; разработчик может создать кастомную модель пользователя и указать эту кастомную модель в качестве основной модели пользователя в проекте.

Если к моменту создания кастомной модели в проекте уже есть какой-то код, работающий с моделью пользователя, — этот код придётся изменять: раньше код обращался к встроенной модели `User`, а теперь нужно будет обращаться к кастомной модели с именем, например, `MyUser`. Придётся перебирать весь код и вносить правки. Нехорошая перспектива.


```python
# Например, код был таким:
result = User.objects.all()

# Но разработчик изменил модель пользователя на кастомную MyUser;
# придётся подправить код:
result = MyUser.objects.all()

# И так по всему проекту.
```


Разработчики Django [рекомендуют](https://docs.djangoproject.com/en/2.2/topics/auth/customizing/#referencing-the-user-model) всегда обращаться к модели пользователя не напрямую, а через функцию `get_user_model()`, даже если модель пользователя не изменена (кто знает, когда понадобится её изменить! Лучше заранее подготовиться к этому).

Функция `get_user_model()` возвращает ту модель, которая зарегистрирована в качестве основной модели пользователя в _settings.py_.


```python
# Получаем модель, зарегистрированную в конфиге проекта,
# в константе AUTH_USER_MODEL
User = get_user_model()

# И в коде применяем значение переменной User, 
# которое вернула функция get_user_model():
result = User.objects.all()
```


Если разработчик повсюду предусмотрительно применял функцию `get_user_model()` — при замене модели пользователя не придётся вносить изменения по всему проекту: вместо прежней модели функция будет возвращать новую.

- Подробности о модели `AbstractUser` всегда можно подсмотреть в [документации](https://docs.djangoproject.com/en/3.2/topics/auth/customizing/#django.contrib.auth.models.AbstractUser).
- Функция `get_user_model()` тоже описана в документации, [вот здесь](https://docs.djangoproject.com/en/3.2/topics/auth/customizing/#django.contrib.auth.get_user_model).

## Класс AbstractBaseUser

Модель пользователя можно перестроить значительно глубже: например, убрать из неё ненужные поля, выбрать для логина поле `email` вместо `username`, а можно и полностью переписать весь процесс аутентификации.

Для этого кастомную модель пользователя надо наследовать не от `AbstractUser`, а от базовой модели `AbstractBaseUser` из модуля `django.contrib.auth.base_user`.

В этом классе прописаны лишь несколько основных полей — например, пароль и время последнего логина, а также [базовые методы](https://docs.djangoproject.com/en/3.2/topics/auth/customizing/#django.contrib.auth.models.AbstractBaseUser) модели пользователя (связанные в основном с обработкой пароля и его сбросом). Все остальные поля и методы надо будет настроить самостоятельно. Как следствие — этот вариант значительно сложнее других вариантов переопределения модели пользователя.

Подробнее о настройке такой кастомной модели пользователя можно почитать [в документации](https://docs.djangoproject.com/en/3.2/topics/auth/customizing/#specifying-a-custom-user-model).


