
[[Питон Практикум]]
[[Фреймворк Django. Работа с проектами]]

## CSRF-атаки

Отправка данных на сервер — потенциально опасная операция для владельца и для пользователей проекта; множество злоумышленников спят и видят, как они используют чужие проекты в своих коварных целях. Нацепим чёрную полумаску, поставим себя на место мошенника и попробуем сжульничать.

В корне рабочей директории компьютера или в какой-нибудь папке для временных файлов создайте HTML-файл для экспериментов; для чистоты эксперимента файл не должен лежать в директории проекта **acme_project.** Имя файла может быть любым, мы назовём его _guile.html_.

Запустите проект **acme_project.**

В файле разместите форму:

```html
<!-- C:/Dev/guile.html -->
<html>
  <head>
    <title>Коварство</title>
  </head>
  <body style="padding:40px;">
    <!-- Адрес отправки формы — проект ACME! -->
    <form action="http://127.0.0.1:8000/birthday/">
      <p>
        <label>Имя</label><br>
        <input type="text" name="first_name" maxlength="20" required>
      </p>
      <p>
        <label>Фамилия</label><br>
        <input type="text" name="last_name" maxlength="20">
      </p>
      <p>
        <label>Дата рождения</label><br>
        <input type="date" name="birthday" required>
      </p>
      <button type="submit">Отправить</button>
    </form>
  </body>
</html>
```

Откройте файл в браузере, заполните и отправьте форму.

Откроется страница проекта **acme_project**; на странице видно, что бэкенд получил и обработал запрос, полученный из посторонней формы, которая не имеет отношения к проекту.

Вроде бы — ничего страшного не случилось. А если бы форма сохраняла данные в базу (ведь именно к этому мы и готовим приложение **birthday**)?

Запрос, отправленный из неизвестного файла, обрабатывается бэкендом — значит, данные из формы запишутся и в БД (или будут выполнены какие-то иные действия, предусмотренные обработчиком).

А теперь представьте, что вы абсолютно случайно, безо всякого умысла, забрели на сайт под названием «Как получить диплом Яндекс Практикума и не мучиться с заданиями. Без смс и регистрации!». И там висит форма: «Введите email, чтобы мы выслали вам диплом».

Это и есть та самая форма злоумышленника.

Ради любопытства вы вводите в форму свой email и нажимаете «Отправить». Ваш email злоумышленнику нужен только для отвода глаз. Важнее, что со своего компьютера вы через форму отправили запрос.

Злоумышленник настроил форму так, что она отправляет POST-запросы на сайт Яндекс Практикума:


```
https://practicum.yandex.ru/delete-all-my-progress/
```


Даже если все страницы Практикума у вас закрыты — ваш браузер, скорее всего, залогинен на этом сайте.

Запрос уйдёт из вашего браузера, и сайт Практикума воспримет этот запрос так, будто вы сами решили сбросить свой прогресс.

«Удалить весь мой прогресс»?! Добро пожаловать на первый урок первого спринта!


## Защита от CSRF

В Django есть встроенная защита от CSRF: она применяется к формам, запросы из которых изменяют состояние данных на сервере (это в первую очередь POST-, DELETE- и PATCH-запросы).

В общих чертах защита реализована так: в HTML-форму встраивается скрытое поле, в котором записан уникальный ключ, — он называется **csrfmiddlewaretoken**; это последовательность букв и цифр, сгенерированная специальным образом.


```html
<form method="post">
  <!-- Вот он, токен в скрытом (type="hidden") поле формы -->
  <input 
    type="hidden" 
    name="csrfmiddlewaretoken" 
    value="WNLJrHCFlC3gEAjra6QZ3oPDyb7ilZCMYp97DQG7II4G7fvhi2Fr9pRlmNWHOzol">
  ...
  <label class="required" for="id_username">Имя пользователя:</label>
  <input type="text" name="username" id="id_username">
  ...
  <input type="submit" value="Войти">  
</form>
```


Похожий токен сохраняется и в cookies браузера (злоумышленник не может подменить `cookies` — они ему недоступны).

В итоге при запросе из поддельной формы

- в форме не будет скрытого поля с csrfmiddlewaretoken;
- в cookies не будет нужного токена.

Когда на сервер приходит запрос, проверяется наличие токена в cookies и токен из формы; если токены обнаружены — они по определённому алгоритму сверяются между собой; запрос считается настоящим только в том случае, если проверка прошла успешно.

Если же проверка не пройдена — вернётся ошибка 403 (недостаточно прав для просмотра страницы), а если проект в режиме разработки — будет выведено такое сообщение об ошибке


При GET-запросах CSRF-токен не нужен — ведь GET-запросы предназначены для получения данных, а не для их изменения. Важно, чтобы разработчик применял методы запросов по назначению — и тогда всё будет в порядке.

## Предъявите токен!

Заглянем под капот и посмотрим, как реализована защита от CSRF в стандартных формах Django. Убедитесь, что проект запущен, — и откройте страницу со стандартной формой аутентификации: [http://127.0.0.1:8000/admin/login/](http://127.0.0.1:8000/admin/login/).


Откройте инструменты разработчика (Dev Tools) в браузере и найдите в HTML-коде страницы описание формы:


```html
<form action="/admin/login/?next=/admin/" method="post" id="login-form">
  <input 
    type="hidden" 
    name="csrfmiddlewaretoken" 
    value="WNLJrHCFlC3gEAjra6QZ3oPDyb7ilZCMYp97DQG7II4G7fvhi2Fr9pRlmNWHOzol">
  <div class="form-row">      
    <label class="required" for="id_username">Имя пользователя:</label>
    <input 
      type="text" name="username" 
      autofocus autocapitalize="none" 
      autocomplete="username" 
      maxlength="150" required 
      id="id_username">
  </div>
  <div class="form-row">      
    <label class="required" for="id_password">Пароль:</label> 
    <input 
      type="password" 
      name="password" 
      autocomplete="current-password" 
      required id="id_password">
    <input type="hidden" name="next" value="/admin/">
  </div>    
  <div class="submit-row">
    <input type="submit" value="Войти">
  </div>
</form>
```


Обратите внимание на первое поле `<input>` с атрибутом `hidden` (этот атрибут скрывает поле от пользователя, однако содержимое этого поля вместе с запросом отправляется на сервер, как и содержимое остальных полей). При генерации формы Django вставил в это поле токен `"WNLJrHCFlC3gEAjra6QZ3oPDyb7ilZCMYp97DQG7II4G7fvhi2Fr9pRlmNWHOzol"`.

В Dev Tools можно найти и cookie, с помощью которого проверяется достоверность запроса:


![[Pasted image 20250515102605.png]]


При каждом обновлении страницы значение токена в форме меняется, новый ключ генерируется при каждой загрузке формы.

Более подробно прочитать и посмотреть, как именно генерируются и сверяются токены CSRF, можно [в документации](https://docs.djangoproject.com/en/3.2/ref/csrf/#how-it-works) или непосредственно [в коде Django](https://github.com/django/django/blob/main/django/middleware/csrf.py).

По умолчанию защита от CSRF в Django включена в middleware `django.middleware.csrf.CsrfViewMiddleware`.

## Защита от CSRF в шаблонах

Из форм, сгенерированных классами `Form` и `ModelForm`, мы пока что отправляли только GET-запросы, и Django без проблем принимал и обрабатывал эти запросы. И даже запрос из «посторонней» формы (из файла _guile.html_) был принят и обработан: ведь это был GET-запрос, а такие запросы только получают информацию, но не меняют её на сервере; эти запросы безопасны.

Но в POST-запросах Django всегда ожидает получить csrf-токен.

Проверим: измените форму в файле _guile.html_ так, чтобы она отправляла запрос методом POST, — и отправьте новый запрос.

```html
<!-- C:/Dev/guile.html -->
<html>
  <head>
    <title>Коварство</title>
  </head>
  <body style="padding:40px;">
    <!-- Указываем метод POST -->
    <form action="http://127.0.0.1:8000/birthday/" method="post">
      <!-- Всё остальное оставляем, как прежде -->
    </form>
  </body>
</html>
```


Ничего не вышло: запрос отклонён; у злоумышленника проблемы: взять уникальный токен негде.

А вот в форму, созданную в Django, встроить csrf-токен можно и нужно. Этот токен не передаётся в объекте формы; нужно добавить тег `{% csrf_token %}` непосредственно в шаблон, в HTML-код формы.

Всё остальное шаблонизатор Django сделает сам.


```html
...
<!-- Для форм, отправляющих POST-запросы, csrf-токен необходим! -->
<form method="post">  
  {% csrf_token %}
  ...
</form>
...
```


Обязательно вставляйте этот тег в формы, которые передают данные методом POST: в любом POST-запросе Django ожидает получить csrf-токен, а в ином случае вернёт ошибку 403.