

У каждого объекта в интернете (у страницы, файла, картинки, каталога) есть уникальный веб-адрес, **URL** (_Uniform Resource Locator_, «унифицированный указатель ресурса»). Чтобы обратиться к нужному объекту — отправляют запрос на URL страницы. Есть два способа указать URL: **абсолютный** путь и **относительный** путь.


## Абсолютные URL

Абсолютный адрес чем-то схож с адресом на конверте. Если в адресе указаны все данные — страна, город, улица, дом, квартира, то это письмо дойдёт по адресу, откуда его ни отправляй, хоть с соседней улицы, хоть с другой стороны земного шара.

Абсолютный URL содержит все сведения, необходимые для получения запрошенной информации, и в общем виде выглядит так:

`<схема или протокол>://<название сервера>/<путь>`


![[Pasted image 20250404175056.png]]



Пример абсолютного адреса — страница документации Django:

`https://docs.djangoproject.com/en/3.2/topics/http/urls/`.

- _https_ — протокол;
- _docs.djangoproject.com —_ доменное имя;
- _/en/3.2/topics/http/urls/ —_ путь.



## Относительные URL

Для доступа к страницам в пределах одного домена применяют **относительные адреса** (относительные URL). Они составляются **относительно** того адреса, с которого отправляется запрос. В относительный адрес не включается адрес домена, а в некоторых случаях — и часть пути.

Например, со страницы с абсолютным адресом `https://docs.djangoproject.com/en/3.2/topics/` можно отправить

- запрос по относительному URL _install/_ — и получить доступ к странице с абсолютным адресом `https://docs.djangoproject.com/en/3.2/topics/install/`;
- запрос по относительному адресу _../_ (две точки — это «на один уровень вверх», точно как в переходе по директориям в консоли) — и получить доступ к странице `https://docs.djangoproject.com/en/3.2/`.



### Маршрутизатор в Django

Адреса, которые будут доступны на сайте, могут быть любыми; обычно их придумывают при составлении `техзадания` к проекту. В ТЗ описывают, какая информация будет доступна при обращении к тому или иному адресу.



![[Pasted image 20250404175637.png]]


Маршрутизатор — это список адресов, на запрос к которым сервер готов дать ответ. Блок «View-функция» — это **обработчик запросов**. Такие функции (их называют **view-функции**) генерируют ответ и отправляют его пользователю.


#### **!!!**
В маршрутизаторах применяют относительные адреса.

```
В качестве адресов могут выступать любые строки, но обычно используют английские слова в нижнем регистре, разделяя их знаками `-` или `_`. Лучше давать такие адреса, чтобы по ним пользователь мог понять, какая информация содержится на странице.
```


### Связь URL и обработчика

Для связи адреса запроса и обработчика применяется функция `path()`. Она принимает обязательные параметры `route` и `view`:

- **route** — шаблон обрабатываемого адреса, это строка-образец, с которой сравнивается полученный запрос. По-русски её называют **маршрут** или **роут**.
- **view** — функция-обработчик: если запрошенный URL совпадает с **route**, вызов будет перенаправлен в указанную view-функцию (view-функции в Django хранят в файле _views.py_). ^bd463e

Когда Django получает запрос к определённому адресу, маршрутизатор вызывает обработчик, связанный с запрошенным адресом. Этот обработчик подготавливает нужные данные для ответа.



Логика проста: если пользователь обращается к относительному адресу _/about/_ — должна быть вызвана view-функция, в которой разработчик опишет, как сгенерировать и отправить пользователю страницу «О компании». Значит, маршрут _/about/_ должен быть связан с этой view-функцией.

В общем виде вызов функции выглядит так:


```python
path('относительный_адрес', <имя обработчика>)

# Например:
path('about/', views.about) 
# Если пользователь обратится к относительному адресу /about/,
# будет вызвана функция about() из файла views.py
```


В Django список путей обычно хранится в файле _urls.py:_


```
acme_project/             <-- Рабочая папка Django-проекта
├── acme_project/         <-- Папка с настройками проекта
|   ├── __init__.py
|   ├── asgi.py
|   ├── settings.py
|   ├── urls.py            <-- Файл с адресами
|   └── wsgi.py
└── manage.py
... 
```


Django будет искать главный файл _urls.py_ по адресу, который указан в константе `ROOT_URLCONF` в файле _settings.py_. Конечно, вы можете изменить этот адрес и сохранить список адресов где угодно, но коллеги будут разочарованы нестандартным подходом: им придётся тратить время и разбираться, куда вы дели этот список и зачем вам это понадобилось.

### Список адресов

Список путей в Django хранится в списке `urlpatterns`. В воображаемом интернет-магазине компании ACME список `urlpatterns` мог бы содержать такие строки:


```python
# Файл urls.py

...

urlpatterns = [
    ...
    # Обрабатываем запрос к главной странице проекта:
    # у неё нет относительного адреса, поэтому вместо шаблона адреса 
    # - пустая строка.
    path('', <имя view-функции, отображающей главную страницу>),

    # Обрабатываем запрос к странице со списком товаров:
    # если получен запрос 'catalog/',
    # будет вызвана функция-обработчик, которая покажет список доступных товаров.
    path('catalog/', <имя view-функции, отображающей список товаров>), 
]
```


### Переменные пути

Редко бывает так, чтобы в магазине был только один товар. Значит, придётся описывать целую серию адресов: `'catalog/1/'`, `'catalog/2/'`, `'catalog/3/'` ... `'catalog/100500/'`. Выглядит странно и нерационально.


При обработке однотипных адресов уникальную часть адреса можно сохранять в переменную и передавать её во view-функцию в качестве аргумента. Для этого в шаблоне адреса имя переменной заключают в треугольные скобки `<>`.


```python
# catalog/urls.py
...

urlpatterns = [
    ...
    # Страница с информацией о товаре
    # с уникальным номером, который равен pk.
    # Имя pk (primary key) — традиционное имя для переменной, 
    # в которой передаётся идентификатор объекта в базе данных.
    path('catalog/<pk>/', views.product_detail),
]
```


Теперь при получении запросов к относительным адресам вида

- _catalog/1/_
- _catalog/100500/_
- _catalog/iron_carrot/_
- _catalog/любая_строка/_

будет вызываться view-функция `product_detail()` из файла _views.py_.


### Конвертеры пути

Функция `path()` всегда получает URL в виде строки, но при обработке запроса бывает важно знать, можно ли преобразовать ту или иную часть пути в определённый тип данных.

В такой ситуации маршрут `path('catalog/<pk>/', views.product_detail)` не подойдёт.

Требуется проверка — какого рода символы переданы в переменной:

- если адрес устроен так: `catalog/<цифры>/` — вызываем view-функцию `product_detail()`;
- если адрес устроен так: `catalog/<буквы>/` — вызываем какую-то другую view-функцию.


Содержимое переменной можно проверить с помощью **конвертеров пути**


Вот список наиболее востребованных конвертеров:

- `str` — ожидает непустую строку, состоящую из любых символов, за исключением разделителя пути `'/'`.
    
    ```python
      path('about/<str:name>/', views.stuff_info),
      # Этот шаблон сработает, если будут запрошены адреса вида
      # about/company/, about/15/ или about/vacancy/
    ```

`int` конвертирует значение переменной в ноль или в целое положительное число.


```python
  path('catalog/<int:pk>/', views.product_detail),
  # Этот шаблон сработает, если будут запрошены адреса вида
  # catalog/1/, catalog/100/, catalog/100500/.
  # А при запросе к адресу catalog/iron_carrot/ 
  # функция product_detail() не будет вызвана.
```


`slug` ожидает строку из цифр, букв латиницы и символов `-` и `_`.

Обычно слаг используют для создания человекочитаемых URL. Адреса с применением slug любят и люди (знающие английский), и поисковые роботы.

```python
  path('article/<slug:category>/', views.article_list_by_category),
  # Этот шаблон сработает, если будут запрошены адреса вида
  # article/chto-takoe-slug/, 
  # article/za-chto-mne-eto/, 
  # article/backend_the_best-part_2/.
  
  # Запрос к адресу article/chto-takoe-slug/part-2/ не сработает: 
  # слеш / не входит в набор символов, допустимых в slug.
  
```


Можно создать и собственный конвертер пути. Например, [конвертер, который будет принимать только четырёхзначное число и игнорировать любые другие параметры](https://docs.djangoproject.com/en/3.2/topics/http/urls/#registering-custom-path-converters).


### Конфликты адресов: кто сверху, тот и главный

Django читает список `urlpatterns` сверху вниз и вызывает обработчик из первого же `path()`, в котором шаблон адреса совпадёт с запросом. Поэтому могут возникать коллизии.

Например, при описанной ниже структуре view-функция `alan_turing()` никогда не будет вызвана: первый шаблон будет перехватывать все запросы к URL вида _page/_.


```python
...
urlpatterns = [
    path('page/', views.maks_karpov),    
    path('page/', views.alan_turing),
] 
```



Шпаргалка

Перечень адресов хранят в файлах _urls.py_ в списке `urlpatterns`.

Разработчик сам придумывает адреса, которые будет обрабатывать приложение.

Django читает список `urlpatterns` сверху вниз и вызывает обработчик из первого же `path()`, в котором шаблон адреса совпадёт с запросом.

Запросы к адресам, которых нет в _urls.py_, вернут ошибку 404 Page not found.

В шаблонах для однотипных адресов можно применять переменные и конвертеры пути.


```python
urlpatterns = [
    path('catalog/<pk>/', views.product_detail),
] 
```

Популярные конвертеры, определяющие тип ожидаемых данных:

- `str` — ожидает любую непустую строку, исключая разделитель пути `'/'`.  
    Если в параметрах пути конвертер не указан явно, то по умолчанию будет применён именно конвертер `str`: шаблон адреса `<username>/` идентичен шаблону `<str:username>/`.
- `int` — ожидает ноль или любое целое положительное число: `<int:pk>/`.
- `slug` ожидает строку из латинских букв, цифр и символов `-` и `_`. `<slug:category_slug>/`.

