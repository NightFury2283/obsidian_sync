[[Питон Практикум]]
[[Фреймворк Django. Работа с проектами]]

acme_project_Forms_training - в VS Code

Задание, с которым вы встретились в прошлом уроке, показало, что можно сверстать веб-форму прямо в Django-шаблоне, подготовить view-функцию, которая примет данные из формы, — и готово, пользователь может отправлять информацию в проект. Такие формы можно вставить в любые шаблоны проекта — и всё заработает. Здорово!

Здорово, но не очень. Django «ничего не знает» про эту форму (точно так же, как не знает про какие-то другие HTML-теги в шаблонах); форма — это просто интерфейс в браузере пользователя; управлять этим интерфейсом из Python невозможно.

А ведь данные, полученные из формы, нужно дополнительно проверить на стороне бэкенда (соответствуют ли они ожидаемым типам и каким-то другим правилам); в ходе развития проекта форму, возможно, придётся изменять — а значит, придётся пройтись по всем шаблонам, в которые встроена форма, и изменить её код. Такой подход чреват ошибками.

В Django есть несколько встроенных специализированных классов для создания форм; знакомство с ними начнём с класса **Form** — он предоставляет все возможности Django по автоматизации работы с формами и берёт на себя всю рутинную работу, которую иначе пришлось бы выполнять вручную:


1. Генерирует HTML-код формы в шаблоне. Разработчику не нужно самому верстать форму, он просто передаёт Python-объект формы из view-функции в шаблон в словаре `context`, как и прочие объекты, предназначенные для вывода на страницу.
2. После того как пользователь заполнил и отправил форму, набор отправленных данных преобразуется в Python-объект; этот объект может быть обработан в том же классе **Form**: при необходимости содержимое полей валидируется (проверяется на соответствие ожидаемым условиям). Например, если какое-то поле ожидает число, то надо убедиться, что полученное значение действительно может быть преобразовано в число.



## Создание класса формы

В приложении _birthday_ создайте файл _forms.py_; в Django-проектах файл, в котором хранят код, управляющий формами, традиционно называют именно так.


```
acme_project/
  ├─ ...
  ├─ birthday/
  │    ├─ migrations/
  │    ├─ __init__.py
  │    ├─ admin.py
  │    ├─ apps.py
  │    ├─ forms.py     <-- Новый файл для форм.
  │    ├─ models.py
  │    ├─ urls.py
  │    └─ views.py
  └─ ...
```


Для создания формы создадим собственный класс, унаследованный от встроенного класса **Form**. В приложении **birthday** будет несколько форм, и для каждой потребуется создать отдельный класс.

Настроим первую форму в проекте; в первом приближении она должна быть такой:


![[Pasted image 20250512114556.png]]


В файле _forms.py_ опишите класс формы `BirthdayForm`, унаследованный от базового класса `django.forms.Form`.

Каждое из полей, которое должно быть у веб-формы, описывается как атрибут класса `BirthdayForm`. Тип каждого поля указывается с помощью специальных классов из модуля `django.forms`; названия этих классов выглядят как `ТипПоляField`:

- `IntegerField` для целочисленных полей,
- `CharField` для текстовых полей,
- `DateField` для полей с датой.

Полный список доступных типов полей можно посмотреть [в документации](https://docs.djangoproject.com/en/3.2/ref/forms/fields/#built-in-field-classes).

```python
# birthday/forms.py
from django import forms


class BirthdayForm(forms.Form):
    first_name = forms.CharField()
    last_name = forms.CharField()
    birthday = forms.DateField()
```


В описании полей можно указать дополнительные атрибуты — например, добавить ограничение на количество символов в поле ввода текста и указать, обязательно ли заполнять поле.

Ограничим длину имени: пусть будет 20 символов; поле фамилии сделаем необязательным (по умолчанию все поля формы обязательны, `required=True` указывать не требуется).

Добавьте этот код в файл _birthday/forms.py_:


```python
# birthday/forms.py
from django import forms


class BirthdayForm(forms.Form):
    first_name = forms.CharField(max_length=20)
    last_name = forms.CharField(required=False)
    birthday = forms.DateField()
```


Класс формы готов, теперь нужно настроить приложение так, чтобы при обращении к адресу _birthday/_ пользователю возвращалась страница с веб-формой, созданной на основе класса `BirthdayForm`.

Маршруты в приложении **birthday** уже настроены; при обращении к адресу _birthday/_ вызывается view-функция `birthday()`, которая вызывает шаблон _birthday.html_.

Приступим: начнём с HTML-шаблона.


## Шаблон для отображения формы

Форма передаётся в шаблон в словаре контекста под ключом `form` (это традиционное название, хотя назвать этот ключ можно как угодно). Переменная `form` содержит HTML-код всех полей формы, но без тега `<form>` и без кнопки отправки формы; эти элементы кода нужно добавить в шаблон вручную.

```html
<!-- templates/birthday/birthday.html -->
{% extends "base.html" %}

{% block content %}
  <form>
    {{ form }}
    <input type="submit" value="Submit">
  </form>
{% endblock %}
```

Скопируйте этот код в файл _birthday.html_.

Весь код формы передан в одной переменной, и нет нужды вручную писать код полей формы в шаблоне.


## Работа с формой во view-функции

При запросе к адресу _birthday/_ вызывается view-функция `birthday()`, в которой должен быть создан **экземпляр** класса формы `BirthdayForm`. Этот экземпляр нужно передать в HTML-шаблон через словарь `context`.

Сделаем же это! Дополните файл _birthday/views.py_ согласно коду ниже:


```python
# birthday/views.py
from django.shortcuts import render

# Импортируем класс BirthdayForm, чтобы создать экземпляр формы.
from .forms import BirthdayForm


def birthday(request):
    # Создаём экземпляр класса формы.
    form = BirthdayForm()
    # Добавляем его в словарь контекста под ключом form:
    context = {'form': form}
    # Указываем нужный шаблон и передаём в него словарь контекста.
    return render(request, 'birthday/birthday.html', context)
```


Откройте страницу _birthday/_; если всё сделано правильно — на странице будет отображена форма, описанная в классе `BirthdayForm`


## Варианты HTML-обрамления формы

Форма, выведенная на страницу _birthday/_, оформлена в виде строк и ячеек HTML-таблицы.

**Таблица** включает в себя **строки**; в теги строк вложены теги ячеек; в ячейках таблицы описано содержимое

`<tr></tr>` — _table row_, строка таблицы,

`<td></td>` — _table data_, ячейка таблицы.

`<th></th>` — _table header_, тоже ячейка таблицы, особая её разновидность: ячейка для заголовка таблицы.

Подробное описание HTML-таблиц [есть в документации](https://developer.mozilla.org/ru/docs/Learn/HTML/Tables/Basics).



Пример:

(нажми на таблицу, там код)

<table border="1" cellspacing="0" cellpadding="5"> <!-- Начало таблицы -->
  <tr> <!-- Начало первой строки (table row) -->
    <td>Первая строка, ячейка 1</td>
    <td>Первая строка, ячейка 2</td>
    <td>Первая строка, ячейка 3</td>
    <td>Первая строка, ячейка 4</td>
  </tr> <!-- Конец первой строки -->
  <tr> <!-- Начало второй строки -->
    <td>Вторая строка, ячейка 1</td>
    <td>Вторая строка, ячейка 2</td>
    <td>Вторая строка, ячейка 3</td>
    <td>Вторая строка, ячейка 4</td>
  </tr> <!-- Конец второй строки -->
  <tr> <!-- Начало третьей строки -->
    <td>Третья строка, ячейка 1</td>
    <td>Третья строка, ячейка 2</td>
    <td>Третья строка, ячейка 3</td>
    <td>Третья строка, ячейка 4</td>
  </tr> <!-- Конец третьей строки -->
</table> <!-- Конец таблицы -->

Аргументы `border`, `cellspacing` и `cellpadding` необязательны; они отвечают за отображение границ таблицы и за отступы внутри ячеек, с ними схема получается нагляднее.

![[Pasted image 20250512120040.png]]


Все элементы таблицы в HTML должны быть обёрнуты в тег `<table></table>`, но класс **Form** этот тег не генерирует, его нужно добавить в шаблон вручную.

Добавьте в код теги `<table>` и `</table>`:


```html
<form>
  <table>
    {{ form }}
  </table>
  <input type="submit" value="Submit">
</form>
```


![[Pasted image 20250512120214.png]]


Для отображения формы есть и другие варианты; указать нужный способ оформления можно с помощью специальных методов. Например, поля можно вывести в виде маркированного списка `<ul>`: для этого в шаблоне указывается метод `form.as_ul`, а вместо тега `<table>` ставится тег `<ul>`.

```html
<form>
  <ul>
    {{ form.as_ul }}
  </ul>
  <input type="submit" value="Submit">
</form>
```


![[Pasted image 20250512120425.png]]


При таком формате вывода поля не выровнены по вертикали, в отличие от варианта с таблицей.

Можно применить метод `form.as_p`, тогда каждое поле будет обёрнуто в тег абзаца `<p>`.

```html
<form>
  {{ form.as_p }}
  <input type="submit" value="Submit">
</form>
```


![[Pasted image 20250512120500.png]]


## Подписи и подсказки к полям формы

По умолчанию заголовки полей HTML-формы генерируются из имён свойств класса формы: имя свойства `first_name` превратилось в лейбл _First name_, а `last_name` — в _Last name_.

Названия полей лучше бы выводить по-русски; для этого нужно немного дополнить класс формы `BirthdayForm`. Заодно добавим в форму сообщение о том, что поле с фамилией необязательно для заполнения — такие подсказки тоже добавляются в описание поля в классе формы.

Кастомные названия полей устанавливаются в аргументе `label`, а подсказка для поля — в аргументе `help_text` нужного поля.

Допишите нужные атрибуты в класс `BirthdayForm`.


```python
# birthday/forms.py
...
class BirthdayForm(forms.Form):
    first_name = forms.CharField(label='Имя', max_length=20)
    last_name = forms.CharField(
        label='Фамилия', required=False, help_text='Необязательное поле'
    )
    birthday = forms.DateField(label='Дата рождения')
```


![[Pasted image 20250512120811.png]]


## Выбор даты

Имя и фамилию пользователь, скорее всего, напишет правильно, но вот с датой могут возникнуть проблемы: если пользователь ошибётся с форматом — бэкенд не сможет преобразовать полученные данные в формат даты — и, соответственно, не сможет провести необходимые вычисления.

Сейчас никто не мешает пользователю ввести дату рождения в любом виде; что в это поле ни напиши — всё будет отправлено.


Необходимо ввести ограничение на формат вводимой строки: в поле для даты в соответствии с настройками проекта ожидается формат `ГГГГ-ММ-ДД` (например, 1799-06-06).

При работе с классом **Form** можно указать, какой интерфейс будет предоставлен пользователю для ввода данных. Например, HTML-тег `<input>` может предоставлять пользователю несколько разных интерфейсов (в зависимости от атрибута `type`): поле ввода текста, поле для чисел, чекбокс…

В описании класса можно указать, какой именно интерфейс нужен для того или иного поля — это делается с помощью **виджетов**.

По умолчанию к каждому типу поля уже подключён определённый виджет, но его можно заменить. Список всех встроенных виджетов можно посмотреть [в документации](https://docs.djangoproject.com/en/3.2/ref/forms/widgets/#built-in-widgets).

Для поля с датой подойдёт виджет, позволяющий пользователю выбрать нужную дату на календаре. Этот виджет не позволит ввести дату в неправильном формате или указать несуществующую дату. При этом у пользователя остаётся возможность ввести дату текстом — и она сразу будет проверена на валидность.


Виджеты указывают в аргументе `widget`; добавьте виджет календаря к полю `birthday` в файле _forms.py_.

```python
# birthday/forms.py
...
class BirthdayForm(forms.Form):
    first_name = forms.CharField(label='Имя', max_length=20)
    last_name = forms.CharField(
        label='Фамилия', required=False, help_text='Необязательное поле'
    )
    birthday = forms.DateField(
        label='Дата рождения',
        # Указываем, что виджет для ввода даты должен быть с типом date.
        widget=forms.DateInput(attrs={'type': 'date'})
    )
```


Теперь дату можно выбрать на календарике, а можно ввести текстом; формат даты изменился: теперь вместо `ГГГГ-ММ-ДД` форма ожидает дату в другом порядке и через точку: `ДД.ММ.ГГГГ`.

Подробнее про виджеты можно прочитать [в документации](https://docs.djangoproject.com/en/3.2/ref/forms/widgets/).