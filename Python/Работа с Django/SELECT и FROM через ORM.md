
[[Питон Практикум]]
[[SQL]]
[[Фреймворк Django. Работа с проектами]]


Сейчас веб-страницы и база данных находятся отдельно: информация из БД видна только в админке. Наша задача — показать эту информацию пользователю.

У нас есть view-функция для главной страницы. В этой функции мы:

- сделаем запрос к модели `IceCream` через ORM: `IceCream.objects.all()`, «получить все объекты модели»;
- получим QuerySet со всеми объектами этой модели;
- передадим этот QuerySet в словарь `context` под каким-нибудь ключом, например, `ice_cream_list`;
- в шаблоне выведем переменную `ice_cream_list`, мы так уже делали.


А теперь о конкретных задачах. Надо подготовить запросы к БД для трёх страниц проекта «Анфиса для друзей»:

- на главную вывести избранные записи из БД,
- на страницу _/ice_cream/_ вывести все объекты `IceCream`, какие есть в базе,
- на страницу _/ice_cream/<pk>/_ вывести полную информацию о запрошенном сорте мороженого.


## Полный список мороженого на главной странице

Обработкой запросов к главной странице занимается view-функция `index()` приложения **homepage**. Вот в ней-то и сделаем запрос к БД: «получить все поля всех объектов модели `IceCream`».

На SQL этот запрос выглядел бы так:

```sql
SELECT *
FROM <имя таблицы>;
```


Но у нас есть Django ORM, так что запрос делаем не на SQL, а на Python:

```python
# homepage/views.py
from django.shortcuts import render

from ice_cream.models import IceCream

def index(request):
    template_name = 'homepage/index.html'
    # Запрос:
    ice_cream_list = IceCream.objects.all()
    # Полученный из БД QuerySet передаём в словарь контекста:
    context = {
        'ice_cream_list': ice_cream_list,
    }
    # Словарь контекста передаём в шаблон, рендерим HTML-страницу:
    return render(request, template_name, context)
```


Посмотрим, какой запрос отправлен для формирования главной страницы. Для чистоты эксперимента надо выйти из аккаунта администратора сайта.

Открываем главную страницу и смотрим запрос через Django Debug Toolbar:

![[Pasted image 20250510212529.png]]


Запросов нет. Это нормально. До тех пор, пока информация из БД не запрошена в шаблоне или каким-то ещё образом, — запросы не отправляются.

А сейчас в шаблоне _index.html_ никакие данные из словаря `context` не выводятся. В такой ситуации Django рассуждает так: «зачем делать запрос, если информация никому не нужна?». Это называется «ленивые запросы»: не пнёшь — не полетят.

Запрос будет отправлен, если в шаблоне будут запрошены данные из словаря `context`; добавим в HTML-шаблон переменную из этого словаря:


```html
 <!-- templates/homepage/index.html -->
...

<h1 class="pb-2 mb-0">Главная страница</h1>
{{ ice_cream_list }}

...
```


И теперь, когда информация из БД востребована в шаблоне, при запросе к главной странице будет отправлен SQL-запрос:


![[Pasted image 20250510212749.png]]


### Метод values(): берём только нужное

В QuerySet содержатся все поля объектов модели `IceCream`, но на странице, которая отправляется пользователю, совершенно не нужны поля `is_published`, `is_on_main`, `wrapper_id` и `category_id`: это техническая информация, не предназначенная для пользователя. Получается, мы напрасно запрашивали эти поля и передавали их в шаблон, создавая лишнюю нагрузку на сервер.

Ограничим количество столбцов, попадающих в выборку. В SQL следовало бы сделать так:

```sql
SELECT <столбец1>, <столбец2>
FROM <имя таблицы>;
```


А в Django ORM поля, которые нужно получить из БД, перечисляются в аргументах метода `.values()`:


```python
<Название модели>.objects.values('<свойство1>', '<свойство2>')
```


При вызове метода `.values()` в QuerySet попадает не список объектов, а список **словарей**; ключами этого словаря служат названия свойств, а значениями — значения этих свойств.


