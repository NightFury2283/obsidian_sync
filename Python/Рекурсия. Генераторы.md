[[Итераторы и генераторы]]
## Рекурсия

Рассмотрим задачу получения факториала числа. В математике он обозначается '!' и функция факториала описывается так:

1. 0! = 1.
2. n! = 1 * 2 * ... * n, n > 0.

Напишем функцию, вычисляющую факториал числа n.

```python
def fact(n):
    factorial = 1
    for i in range(2, n + 1):
        factorial *= i
    return factorial


print(fact(5))
```



Давайте напишем рекурсивную функцию для вычисления факториала. При создании рекурсивных функций необходимо:

1. Написать, что вернёт функция при начальном значении аргумента.
2. Написать правило получения нового значения на основе уже вычисленных на предыдущих шагах.

```python
def fact(n):
    if n == 0:  # 0! = 1
        return 1
    return fact(n - 1) * n  # n! = (n - 1)! * n


print(fact(5))
```

Вывод программы:

120


Проблема рекурсии, в вызове одинаковых значений, так как мы их не храним.

Для ускорения вычислений нужно запоминать уже посчитанные числа последовательности, а затем использовать их при необходимости. Такой подход называют кешированием или мемоизацией.


Напишем рекурсивную функцию с кешированием, использовав для сохранения вычисленных значений словарь, в котором ключами будут номера чисел последовательности, а значениями — сами числа.

```python
def fib(n):
    global count
    count += 1
    if n not in cash:
        cash[n] = fib(n - 1) + fib(n - 2)
    return cash[n]


count = 0
cash = {0: 1, 1: 1}
print(f"35-е число Фибоначчи равно: {fib(35)}.")
print(f"Количество вызовов рекурсивной функции равно: {count}.")
```


## Лимит рекурсии
### RecursionError: maximum recursion depth exceeded

Программа выдала ошибку по превышению глубины рекурсии. В Python по умолчанию максимальный размер глубины рекурсии равен 1000. Чтобы изменить глубину рекурсии для вашей программы, нужно вызвать функцию `setrecursionlimit()` из стандартного модуля `sys` и передать новое значение для предела глубины.

```python
решение 1
from timeit import timeit
from sys import setrecursionlimit


def fib(n):
    if n not in cash:
        cash[n] = fib(n - 1) + fib(n - 2)
    return cash[n]


setrecursionlimit(2000)
cash = {0: 1, 1: 1}
print(f"Среднее время вычисления: "
      f"{round(timeit('fib(1000)', number=10, globals=globals()) / 10, 6)} с.")
```

Вывод программы:

Среднее время вычисления: 0.000132 с.


Итак, наша рекурсивная функция с кешированием стала работать быстро. Однако есть и недостаток: её код стал читаться сложнее. Поручим процесс запоминания промежуточных значений функции интерпретатору. Для этого в Python в стандартном модуле `functools` есть функция `lru_cache`. Её следует использовать так, как показано в следующем примере:

```python
решение 2
from timeit import timeit
from functools import lru_cache


@lru_cache(maxsize=1000)
def fib(n):
    if n in (0, 1):
        return 1
    return fib(n - 1) + fib(n - 2)

    
print(f"Среднее время вычисления: "
      f"{round(timeit('fib(35)', number=10, globals=globals()) / 10, 6)} с.")
```

Вывод программы:

Среднее время вычисления: 2e-06 с.



## Генераторы

Функции в Python могут возвращать в качестве значения объект-генератор. С генераторами мы сталкивались, когда использовали списочные выражения без сохранения значений в список:

```
squares = (i ** 2 for i in range(10))
print(squares)
```

Вывод программы:

<generator object <genexpr> at 0x000001C225EFC9E0>


Генератор хранит в памяти одно текущее значение и может вернуть следующее, если для него вызывается метод `__next__()`. Для создания функции-генератора необходимо вместо возврата значения с помощью `return` использовать оператор `yield`. Этот оператор приостанавливает работу функции и возвращает значение функции тогда, когда для неё вызывается метод `__next__()`, например при проходе по значениям генератора в цикле.

Напишем функцию-генератор для последовательности Фибоначчи:

```python
def fib(n):
    n_1, n_2 = 1, 1
    for i in range(n):
        yield n_1
        n_1, n_2 = n_2, n_1 + n_2


print(", ".join(str(x) for x in fib(10)))
```




[[Python]]
[[Яндекс Контест]]
