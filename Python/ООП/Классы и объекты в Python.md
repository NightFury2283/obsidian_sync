[[Принципы ООП]]
[[Питон Практикум]]

Типы данных `str`, `int` и другие — всё это классы. А конкретные строки, числа, списки, словари — объекты этих классов.

Объект класса часто называют **экземпляром класса**. В курсе будут использоваться оба понятия.

## **Атрибуты**

Итак, у вас есть объект `address`, который относится к классу `str`:


```
address = 'На деревню дедушке' 
```

Вы можете создать ещё один объект класса `str`, например `recipient`:


```
address = 'На деревню дедушке'
recipient = 'Константин Макарыч' 
```

Теперь у вас есть два разных объекта, `address` и `recipient`, которые принадлежат к одному классу. Принадлежность к классу — это **атрибут**, характеристика объекта. Такой атрибут называется `__class__`. К нему можно обратиться с помощью точечной нотации: `имя_объекта.атрибут`.

Получается, чтобы посмотреть на атрибут принадлежности к классу объектов `address` и `recipient`, нужно написать такой код:


```
address = 'На деревню дедушке'
recipient = 'Константин Макарыч'

print(address.__class__)
print(recipient.__class__)

# <class 'str'>
# <class 'str'> 
```


## **Методы**

Это функции, связанные с объектами. Например, с помощью метода `upper()` можно перевести все буквы в строке в верхний регистр :

Скопировать код

PYTHON

```
address = 'На деревню дедушке'
uppercase_address = str.upper(address)
print(uppercase_address)

# Выведется:
# НА ДЕРЕВНЮ ДЕДУШКЕ
```

Здесь объект `address` передаётся в качестве аргумента методу `upper()` класса `str`

Но можно сделать иначе. `address` — объект класса `str`, и к этому объекту можно применить любой метод, с которым умеет работать класс `str`. Делается это по такому шаблону: `имя_объекта.метод()`. Обратите внимание на скобки в шаблоне — у метода могут быть аргументы, поэтому скобки обязательны:


```
address = 'На деревню дедушке'
uppercase_address = address.upper()
print(uppercase_address)

# Выведется:
# НА ДЕРЕВНЮ ДЕДУШКЕ 
```


Также, возможно, вы заметили, что некоторые атрибуты написаны странно — например, `__class__`. Тут есть подчёркивания. Это неспроста. Подчёркиваниями с обеих сторон выделяются названия **специальных атрибутов и методов**. Так их проще отличить от обычных. Такие специальные атрибуты и методы ещё называют **«магическими»**.


## Специальные, или магические, атрибуты и [[Классы и объекты в Python|объекты]]

Специальные, или магические, атрибуты и методы — это «настройки по умолчанию». Как, например, у смартфона есть заводские настройки, так и почти у всех объектов и классов в программировании есть магические атрибуты и методы. У них особенный синтаксис — в начале и в конце названия ставится по два подчёркивания, вот так: `__название__`.

Пример такого магического метода — `__add__()`. Он есть у всех классов и объектов. Этот метод знает, как действовать, когда вы используете оператор `+`. Вы можете использовать этот оператор для решения разных задач: сложения чисел, конкатенации строк, объединения списков.

Магический метод `__add__()` распознаёт задачу и всегда знает, как поступить с данными в каждом конкретном случае. Вам не нужно вызывать этот метод и что-то разъяснять ему, достаточно просто написать `2 + 3` или `'роман' + 'тик'`, и каждый раз вы будете получать нужный результат.

Программисты обычно не вызывают магические методы и атрибуты напрямую. Эти методы и атрибуты, как правило, просто сообщают Python, как обрабатывать объекты и классы в определённых ситуациях.

## Как объявить класс

Для объявления классов в Python используется уже знакомый вам шаблон — такой же, как и для объявления функций, циклов и ветвлений.

Вам нужно:

1. Написать ключевое слово `class`.
2. Указать имя класса.
3. Поставить двоеточие.
4. Описать тело класса с отступом в четыре пробела.


```
# Ключевое слово class и имя класса.
class ИмяКласса:
    # Тело класса.
    ... 
```


## Как давать имена классам

Имена классам принято давать по правилам:

- Пишите имя класса на английском и с большой буквы.
- Если имя класса состоит из нескольких слов, используйте _CamelCase_ (англ. «ВерблюжийРегистр», также «ГорбатыйРегистр», «СтильВерблюда»), то есть каждое слово пишите с большой буквы, между словами не используйте пробелы или подчёркивания.
- Часто классы — это концепции из реального мира, поэтому выбирайте для их названий существительные.
- Выбирайте понятные и информативные имена. Они должны отражать назначение класса.
- Старайтесь избегать аббревиатур или неочевидных сокращений, если они не общеприняты.
- Не используйте имена, которые уже заняты встроенными типами или классами в Python.


**Pass**:


```
class Phone:
    pass
```

У вашего класса пока нет ни методов, ни атрибутов, поэтому в теле функции поставлена «заглушка» — инструкция `pass`.


## Объект или экземпляр класса

Хоть класс пока и пуст, вы всё равно можете создавать его экземпляры. Просто позовите класс по имени, как если бы это была функция, и присвойте результат переменной:


```
class Phone:
    pass


# Создать экземпляр класса Phone().
my_phone = Phone() 
```


## Атрибуты класса

Атрибуты класса прописываются в теле класса. Они объявляются как обычные переменные: нужно задать название атрибута и присвоить ему значение.

Например, если в классе `Phone` нужно абстрагировать проводные телефоны, то можно добавить в этот класс атрибут `line_type` и присвоить ему значение `'проводной'`:


```
class Phone:
    # Вот здесь объявлен атрибут класса.
    line_type = 'проводной' 
```


Созданным объектам доступны все атрибуты класса `Phone`, а именно атрибут `line_type`. Доступ к этому атрибуту можно получить через точечную нотацию:


```
class Phone:
    line_type = 'проводной'


rotary_phone = Phone()
keypad_phone = Phone()

# Печать содержимого атрибута line_type через объект rotary_phone.
print(rotary_phone.line_type)
# Печать содержимого атрибута line_type через объект keypad_phone.
print(keypad_phone.line_type)

# Выведется:
# проводной
# проводной 
```


## Магический метод `__init__` и атрибуты объекта

Под капотом Python в конструкторе класса объект «формируется» в два этапа:

- сперва магический метод `__new__` **создаёт** новый объект класса,
- затем магический метод `__init__` **инициализирует** объект — устанавливает для него значения атрибутов, переданных в конструктор класса.

**Создание объекта** выполняется магическим методом `__new__`. Как правило, при работе с классами его почти никогда не описывают явно: в большинстве случаев вполне достаточно того, как этот метод работает под капотом.

**Инициализация объекта** выполняется магическим методом `__init__`, этот метод называют «инициализатор класса» или просто «инит».

Атрибуты объектов каждого конкретного класса описываются именно в методе `__init__`, и если у объектов должны быть атрибуты — разработчик должен явным образом описать этот метод в классе.


А класс с конструктором будет таким:

```
class ИмяКласса:
    # Тут можно указать атрибуты класса.
    ...

    # Объявлен конструктор.
    def __init__(self, ...):
        ... 
```

#### **!!!**
Первым параметром в методы экземпляра всегда передаётся параметр `self` (англ. «сам»). `self` — это указатель на объект, который вы создаёте. Мы не рекомендуем называть `self` как-то иначе. Хотя Python не выдаст ошибку, это считается плохой практикой. Используя другое имя, вы запутаете тех, кто будет читать ваш код. Аргумент с названием `self` — устоявшееся соглашение, которому следуют программисты по всему миру.



Теперь можно объявлять атрибуты объекта:


```
class Phone:

    line_type = 'проводной'

    def __init__(self, dial_type_value):
        # Вот он - атрибут объекта.
        self.dial_type = dial_type_value


... 
```

Здесь `dial_type` — это атрибут объекта, `dial_type_value` — значение для атрибута объекта, которое берётся из параметра конструктора.


Значение атрибута обычно задаётся при создании объекта:


```
class Phone:

    line_type = 'проводной'

    def __init__(self, dial_type_value):
        self.dial_type = dial_type_value


# Создать объект rotary_phone со значением dial_type_value,
# равным 'дисковый'.
rotary_phone = Phone(dial_type_value='дисковый')
# Создать объект keypad_phone со значением dial_type_value,
# равным 'кнопочный'.
keypad_phone = Phone(dial_type_value='кнопочный') 
```


## Замена значений атрибутов


Чтобы поменять значение атрибута объекта, нужно:

1. Создать объект с первоначальным значением атрибута.
2. Через объект обратиться к атрибуту и задать ему новое значение.

```
class Phone:
    # Атрибут класса.
    line_type = 'проводной'
    
    def __init__(self, dial_type_value):
        # Атрибут объекта.
        self.dial_type = dial_type_value

# Создать объект класса Phone с первоначальным значением 
# атрибута объекта dial_type.
rotary_phone = Phone(dial_type_value='дисковый')

print(f'Тип набора: {rotary_phone.dial_type}')

# Поменять первоначальное значение атрибута объекта dial_type.
rotary_phone.dial_type='кнопочный'

print(f'Тип набора: {rotary_phone.dial_type}')

# Выведется: 
# Тип набора: дисковый
# Тип набора: кнопочный
```



Значение атрибута класса тоже можно поменять, но для его изменения не обязательно создавать объект. К атрибуту класса можно обратиться напрямую — через класс:



```
class Phone:
    # Атрибут класса.
    line_type = 'проводной'
    
    def __init__(self, dial_type_value):
        self.dial_type = dial_type_value

# Распечатать значение атрибута класса line_type.
print(f'Тип линии: {Phone.line_type}')
# Поменять значение атрибута класса line_type.
Phone.line_type = 'беспроводной'
# Распечатать новое значение атрибута класса.
print(f'Тип линии: {Phone.line_type}')

# Выведется: 
# Тип линии: проводной
# Тип линии: беспроводной 
```

Если значение атрибута класса попытаться поменять через объект, то в этом случае новое значение получит только этот объект:



```
class Phone:
    # Атрибут класса.
    line_type = 'проводной'
    
    def __init__(self, dial_type_value):
        # Атрибут объекта.
        self.dial_type = dial_type_value


# Создать объект класса Phone.
rotary_phone = Phone(dial_type_value='дисковый')
keypad_phone = Phone(dial_type_value='кнопочный')

# Распечатать значение атрибута класса.
print(f'Тип линии: {rotary_phone.line_type}')
print(f'Тип линии: {keypad_phone.line_type}')

# Поменять значение атрибута line_type для объекта rotary_phone.
rotary_phone.line_type = 'радио'

# Снова распечатать значения.
print(f'Тип линии: {rotary_phone.line_type}')
print(f'Тип линии: {keypad_phone.line_type}')

# Поменять значение атрибута класса через класс.
Phone.line_type = 'спутниковый'

# Снова распечатать значения.
print(f'Тип линии: {rotary_phone.line_type}')
print(f'Тип линии: {keypad_phone.line_type}')
```


Значение атрибута класса было изменено уже после того, как объект `keypad_phone` был создан, однако объект всё равно «увидел» новое значение. **Объект не хранит значение атрибута класса, а лишь ссылается на него.**


Если же в объекте явно задать новое значение атрибута с именем атрибута класса, как это было сделано с объектом `rotary_phone`, то объект сохранит собственное значение, а не ссылку на класс.





