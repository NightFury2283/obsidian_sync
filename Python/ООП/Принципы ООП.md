
#### **!!!**
- Когда вы вызываете метод объекта через точку (`obj.method()`), Python автоматически подставляет сам объект (`self`) в качестве первого аргумента

У парадигмы объектно-ориентированного программирования четыре принципа:

- абстракция,
- наследование,
- инкапсуляция,
- полиморфизм.


Абстракция — это использование только значимых характеристик объекта и игнорирование всего остального. Чем меньше характеристик, тем лучше абстракция, но ключевые характеристики убирать нельзя.


Для работы с абстракциями используются **интерфейсы**. Например, для дома интерфейсом будет цвет. Это свойство дома, которое можно изменить.

**Интерфейс класса** — это функциональная часть класса. В ООП интерфейсами называют свойства и методы класса, используя которые можно взаимодействовать с объектом этого класса из любого места в программе.

## Наследование

Так называют возможность на основе существующих классов создавать классы-наследники.

```
Наследование — возможность описать новый класс на базе существующего. При этом дочерние классы могут заимствовать свойства и методы родительского класса.
```


## Инкапсуляция


Когда вы применяете методы встроенного в интерпретатор класса или класса из стороннего модуля, для вас важно лишь, какие данные в этот метод надо передать и что метод возвращает. Сама реализация может быть скрыта от вас, и это не помешает вам получить нужный результат. Такое использование методов формирует ещё один принцип ООП.

```
Инкапсуляция — объединение и скрытие методов и свойств и предоставление доступа к ним через простой внешний интерфейс.
```


## Полиморфизм

```
Полиморфизм — возможность взаимодействовать с объектами разных классов через одинаковые интерфейсы; обращаться к свойствам и методам, общим для всех объектов.
```


## Родительский класс

Родительский класс телефона у вас уже есть — `Phone`. Это обычный класс с инициализатором, атрибутами и методами, с помощью которого можно создавать объекты:

```
class Phone:
    line_type = 'проводной'

    def __init__(self, dial_type_value):
        self.dial_type = dial_type_value

    def ring(self):
        print('Дзззззыыыыыыыынь!')

    def call(self, phone_number):
        print(f'Звоню по номеру {phone_number}! Тип связи - {self.line_type}.')


rotary_phone = Phone('дисковый')

print(rotary_phone.line_type)
rotary_phone.ring()

# Выведется:
# проводной
# Дзззззыыыыыыыынь!
```


## Дочерний класс

Чтобы создать дочерний класс, нужно унаследовать его от родительского класса.

Для этого используется синтаксис наследования:

```
class ИмяКлассаНаследника(ИмяРодительскогоКласса):
    pass
```

#### **!!!**

В Python обычно необходимо сначала объявить родительский класс, прежде чем вы сможете создать дочерний класс, который от него наследуется. Это связано с тем, что Python интерпретирует код последовательно, сверху вниз. Если вы попытаетесь объявить дочерний класс до того, как родительский класс будет определён, интерпретатор Python выдаст ошибку, так как он не сможет найти определение родительского класса в момент создания дочернего.

```
# Правильный порядок.
class Parent:
    pass

class Child(Parent):
    pass 
```


## Переопределение атрибутов и методов

Дочерний класс `MobilePhone` унаследовал всё-всё, что есть в родительском классе `Phone`, в том числе и атрибут `line_type` со значением `проводной`. Но мобильные телефоны для передачи связи используют не проводные линии, а беспроводные. Это можно отразить в вашем коде, ведь в дочернем классе можно переопределять и расширять атрибуты и методы, унаследованные от родительского класса. Для этого при описании дочернего класса нужно объявить атрибут или метод с таким же именем, как в родительском классе, и описать его по-новому.

```
class MobilePhone(Phone): 

# Переопределить значение атрибута line_type класса Phone. 
line_type = 'беспроводной' 

# Переопределить метод ring() класса Phone. 
def ring(self): 
	print('Дзынь-дзынь!')
```


## Добавление новых атрибутов и методов


Для создания такого атрибута вам понадобится инициализатор класса. В дочернем классе его не нужно описывать с нуля — можно задействовать родительский инициализатор. Нужно лишь расширить его дополнительным кодом по такому плану:

1. Объявить инициализатор класса `MobilePhone`.
2. Добавить в него новый атрибут `network_type`.
3. Вызвать родительский инициализатор. Для этого вам понадобится функция `super()`.


```
class Phone:

    line_type = 'проводной'

    def __init__(self, dial_type_value):
        self.dial_type = dial_type_value

    def ring(self):
        print('Дзззззыыыыыыыынь!')

    def call(self, phone_number):
        print(f'Звоню по номеру {phone_number}! Тип связи - {self.line_type}.')


class MobilePhone(Phone):
    line_type = 'беспроводной'
    battery_type = 'Li-ion'

    # Инициализатор класса MobilePhone с новым параметром - network_type.
    def __init__(self, dial_type_value, network_type):
        # Новый атрибут объекта.
        self.network_type = network_type
        # Вызов родительского инициализатора.
        super().__init__(dial_type_value)

    def ring(self):
        print('Дзынь-дзынь!') 
```


У объектов дочерних классов есть доступ к атрибутам и методам родительского класса, а вот объекты родительского класса не могут воспользоваться возможностями дочернего.


В Python все классы напрямую или через классы-родители — наследники встроенного базового класса `object`. Это значит, что все классы в Python могут использовать методы класса `object`. Например, знакомый вам метод `__str__()` определён именно в классе `object`.

**Шпора**
https://code.s3.yandex.net/Python-dev/cheatsheets/089-oop-osnovnye-printsipy-shpora/089-oop-osnovnye-printsipy-shpora.html
