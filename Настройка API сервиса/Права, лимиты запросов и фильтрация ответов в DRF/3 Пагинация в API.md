[[Фреймворк Django. Работа с проектами]]
[[Python]]
[[API]]
[[Питон Практикум]]


Рост популярности Kittygram выявил и другие интересные моменты. Сейчас в базе хранится значительное количество информации о разных котиках. В результате GET-запрос к эндпоинту `/cats/` вернёт сразу 100500 объектов.

Пользователи недовольны, у них проблемы: API возвращает гору информации, в которой сложно разобраться; пользователям обычно не нужен весь список котиков, но ограничить количество объектов в ответе невозможно; обработка большого ответа требует дополнительного времени и ресурсов.

Поэтому ваша новая задача — сделать так, чтобы возвращать ответ не полным списком, а частями.


С аналогичной задачей вы уже встречались, настраивая вывод постов на фронтенд. Тогда вы использовали **пагинацию** (от англ. _pagination_, «система разделения выдачи на страницы»). В Django REST Framework тоже есть пагинация, надо только разобраться с ней и подключить к API Kittygram.

### Пагинация на уровне проекта

В составе DRF по умолчанию доступны несколько классов пагинации. Начнём с самого простого класса: `PageNumberPagination`. Он делит выдачу на части и дополнительно добавляет в ответ API счётчик страниц и ссылки на предыдущую и следующую «страницы» с результатами.

Пагинацию можно включить на уровне всего проекта, добавив ключи `DEFAULT_PAGINATION_CLASS` и `PAGE_SIZE` в словарь настроек `REST_FRAMEWORK`. Именно они отвечают за подключение пагинатора и число объектов в выдаче.

```python
# kittygram2plus/settings.py
...

REST_FRAMEWORK = {
    ...
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
    'PAGE_SIZE': 5,
}
```


Пагинация «из коробки» будет работать только для дженериков и вьюсетов. Для view-классов пагинацию настраивают иначе; детали реализации можно [подсмотреть](https://github.com/encode/django-rest-framework/blob/98e56e0327596db352b35fa3b3dc8355dc9bd030/rest_framework/generics.py#L24) в исходном коде классов `mixins.ListModelMixin` и `generics.GenericAPIView`.

В настройках пагинации мы установили выдачу пяти объектов на «страницу». Если в БД есть более пяти записей о котиках, то при GET-запросе к эндпоинту `/cats/` вернётся примерно такой ответ:


```json
{
    "count": 7,
    "next": "http://127.0.0.1:8000/cats/?page=2",
    "previous": null,
    "results": [
        {
            "id": 1,
            "name": "Мурка",
            "color": "White",
            "birth_year": 2017,
            "achievements": [],
            "owner": 1,
            "age": 4
        },
        ...
        {
            "id": 5,
            "name": "Пончик",
            "color": "Mixed",
            "birth_year": 2019,
            "achievements": [
                {
                    "id": 1,
                    "achievement_name": "уронил вазу"
                },
                {
                    "id": 2,
                    "achievement_name": "напал из-за угла"
                }
            ],
            "owner": 1,
            "age": 2
        }
    ]
}
```


Обратите внимание: если раньше список объектов был прямо в теле JSON, то теперь объекты вложены в список `results`.


### Пагинация на уровне view-класса

Пагинацию можно установить для отдельного view-класса (для _Generics_ или _Viewsets_), указав класс пагинатора в атрибуте `pagination_class`. Если пагинация одновременно установлена и на уровне проекта, и на уровне класса — приоритет будет у настроек класса.


```python
from rest_framework.pagination import PageNumberPagination


class CatViewSet(viewsets.ModelViewSet):
    queryset = Cat.objects.all()
    serializer_class = CatSerializer
    permission_classes = (permissions.IsAuthenticatedOrReadOnly,)
    pagination_class = PageNumberPagination
```


Для `PageNumberPagination`, установленного в классе, параметр `PAGE_SIZE` будет взят из словаря `REST_FRAMEWORK` в _settings.py._

Если пагинация установлена на уровне проекта, то для отдельного класса её можно отключить, установив для атрибута `pagination_class` значение `None`.



### Новая структура ответа

Добавление пагинации изменило структуру выдачи, и если пользователи Kittygram или другие сервисы уже пользуются нашим API — у них будут проблемы: после таких изменений извлечь данные из выдачи не удастся, придётся переписывать обработчики.

В уроке про проектирование API уже разбиралась похожая ситуация. Выходом из неё может быть выпуск следующей версии API (в нашем случае — `/v2/`), а для прежних клиентов можно оставить доступной текущую версию (пусть клиенты сами решат, когда перейти на новую).

Другое важное изменение состоит в том, что при включённой пагинации запрос к API теперь можно делать с дополнительным параметром `page`:


```
GET http://127.0.0.1:8000/cats/?page=2
```


Значением этого параметра должно быть целое число, указывающее на нужную «страницу» выдачи. Нумерация «страниц» начинается с единицы.


![[Pasted image 20250804212152.png]]


У объекта выдачи также появились поля `count`, `next` и `previous`: это общее количество объектов и URL'ы следующей и предыдущей страниц. Эти поля упрощают работу с выдачей: например, в интерфейсе поиска можно вывести информацию «Найдено `{count}` элементов» и дать ссылки для загрузки предыдущей и следующей страниц с результатами поиска.


### Класс LimitOffsetPagination

Помимо `PageNumberPagination` есть и более гибкий класс для пагинации: `LimitOffsetPagination`.

При работе с классом `PageNumberPagination` разработчик жёстко устанавливает разбиение по страницам, а класс `LimitOffsetPagination` даёт возможность клиенту самостоятельно определять, какое число объектов вернётся (параметр `limit`) и с какого по счёту объекта начать отсчёт (параметр `offset`).

Подключим этот класс к `CatViewSet` и посмотрим на результат его работы:


```python
...
from rest_framework.pagination import LimitOffsetPagination


class CatViewSet(viewsets.ModelViewSet):
    queryset = Cat.objects.all()
    serializer_class = CatSerializer
    permission_classes = (OwnerOrReadOnly,)
    # Даже если на уровне проекта установлен PageNumberPagination
    # Для котиков будет работать LimitOffsetPagination
    pagination_class = LimitOffsetPagination
```


При пагинации посредством `LimitOffsetPagination` GET-запрос должен выглядеть примерно так:


```
GET http://127.0.0.1:8000/cats/?limit=2&offset=4
```


Такой GET-запрос вернёт два объекта, с пятого по шестой (или меньше, если в результате запроса менее 6 объектов).

```json
{
    "count": 7,
    "next": "http://127.0.0.1:8000/cats/?limit=2&offset=6",
    "previous": "http://127.0.0.1:8000/cats/?limit=2&offset=2",
    "results": [
        {
            "id": 5,
            "name": "Пончик",
            "color": "Mixed",
            "birth_year": 2019,
            "achievements": [
                {
                    "id": 1,
                    "achievement_name": "уронил вазу"
                },
                {
                    "id": 2,
                    "achievement_name": "напал из-за угла"
                }
            ],
            "owner": 1,
            "age": 2
        },
        {
            "id": 6,
            "name": "Марсель",
            "color": "Mixed",
            "birth_year": 2019,
            "achievements": [
                {
                    "id": 1,
                    "achievement_name": "уронил вазу"
                },
                {
                    "id": 2,
                    "achievement_name": "напал из-за угла"
                }
            ],
            "owner": 1,
            "age": 2
        }
    ]
}
```


Для решения большинства стандартных задач вполне хватает классов `PageNumberPagination` и `LimitOffsetPagination`, но в DRF есть и другие пагинаторы; узнать о них можно в [документации](https://www.django-rest-framework.org/api-guide/pagination/#api-reference).

### Пользовательский класс пагинации

Класс `PageNumberPagination` настраивается в _settings.py_, и указать там отдельное значение для конкретного вьюсета невозможно. Даже если прописать пагинатор прямо во вьюсете — размер выдачи он всё равно возьмёт из настроек проекта.

Если все эндпоинты должны возвращать одинаковое количество объектов на странице — проблем нет. Но так будет не всегда. Поэтому нужно изменить выдачу: котиков будем возвращать по двадцать на странице, а все остальные объекты — по пять.

Готовые классы для этой задачи не подходят, будем писать собственный.

Кастомный пагинатор наследуют от подходящего встроенного класса или от базового `BasePagination`. После этого в кастомном пагинаторе можно переопределить необходимые параметры. Всё знакомо.

Приступим: опишем собственный класс `CatsPagination`, унаследованный от `PageNumberPagination`, и переопределим нужные [параметры](https://www.django-rest-framework.org/api-guide/pagination/#configuration): нам нужен только `page_size`.

Собственные классы пагинаторов принято описывать и хранить в файле _pagination.py_.


```python
# cats/pagination.py
from rest_framework.pagination import PageNumberPagination

class CatsPagination(PageNumberPagination):
    page_size = 20
```


Пагинатор `CatsPagination` готов, его можно указывать в настройках пагинации во вьюсетах, дженериках или в глобальных настройках проекта.


```python
from .pagination import CatsPagination

class CatViewSet(viewsets.ModelViewSet):
    queryset = Cat.objects.all()
    serializer_class = CatSerializer
    permission_classes = (permissions.IsAuthenticatedOrReadOnly,)
    # Вот он наш собственный класс пагинации с page_size=20
    pagination_class = CatsPagination
```


Задача решена: котиков теперь выдаём по 20 штук, остальные ресурсы — по пять объектов на странице. Руководитель разработки и пользователи довольны. Премии всей команде!

### Методы paginate_queryset и get_paginated_response

В базовом классе пагинаторов `BasePagination` определены два метода:

- `paginate_queryset(self, queryset, request, view=None)`: в него передаётся исходный queryset, а возвращает он итерируемый объект, содержащий только данные запрашиваемой страницы;
- `get_paginated_response(self, data)`: принимает сериализованные данные страницы, возвращает экземпляр Response.

При описании собственных классов-пагинаторов эти методы тоже можно переопределять — например, если нужно изменить структуру ответа или названия полей в нём. Эта информация вам точно пригодится при решении задач в тренажёре. [Примеры из документации](https://www.django-rest-framework.org/api-guide/pagination/#example) тоже помогут.


