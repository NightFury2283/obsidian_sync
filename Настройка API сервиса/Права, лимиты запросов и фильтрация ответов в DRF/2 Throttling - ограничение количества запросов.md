[[Фреймворк Django. Работа с проектами]]
[[Python]]
[[API]]
[[Питон Практикум]]

Популярность Kittygram растёт: владельцы котиков ежедневно добавляют на сервис новых и новых зверей, описывают их разнообразные достижения; количество зарегистрированных котовладельцев тоже растёт.

Рост популярности принёс не только радость, но и новые задачи: большое количество запросов стало так нагружать систему, что она периодически стала возвращать [ошибки группы 5хх](https://www.django-rest-framework.org/api-guide/status-codes/#server-error-5xx).

Игнорировать эту ситуацию нельзя.


С высокой долей вероятности можно предположить, что это не уникальная проблема, и для её решения кто-нибудь что-нибудь уже придумал.

Действительно, в DRF уже есть встроенный механизм для решения этой задачи: **тротлинг** (от англ. _throttling_, «регулирование»). Ну что ж, это отличный повод изучить что-то новое.

### Тротлинг

Как и в случае с пермишенами, **тротлинг** определяет, можно ли разрешить запрос к API. Отличие в том, что тротлинг устанавливает ограничение на лимит запросов и определяет разрешённую частоту обращений к API. Это позволяет контролировать нагрузку на сервер и отсекать клиентов, которые слишком часто отправляют запросы.

Можно установить лимит на количество запросов в секунду, минуту, час или день; можно определить лимиты для одного клиента, например — 1000 запросов в день и 100 запросов в час. Можно создать ограничения на определённые действия, например, на загрузку фотографий на сервер.

Если пользователь не аутентифицирован, то он идентифицируется по ip-адресу, с которого отправляются запросы.

При превышении лимита возвращается статус-код **429 “Too Many Requests”.**


Лимиты можно установить для всего проекта, можно — для конкретных view-функций или классов, а можно скомбинировать оба эти подхода.

Распространённая практика — задать глобальные настройки для всего проекта, а затем уточнить их на уровне классов или функций. Логика та же, что и с пермишенами.

## Лимиты на уровне проекта

Изучение логов Kittygram показало: именно разрешение анонимных запросов котиков в API привело к резкому росту обращений. Возможно, это связано с популярностью проекта, а возможно — с деятельностью недоброжелателей или ботов.

Как бы то ни было — сервис не должен падать, и после анализа трафика разработчикам поставлена задача ограничить суточное количество запросов: тысяча запросов от анонимных пользователей и десять тысяч — от аутентифицированных. И ни запросом больше.

Пользователь, который не прошёл процедуру аутентифицикации, в Django называется анонимным, _anonymous, с_окращённо — _anon_. Прошедший аутентификацию — _user_.

Ограничения на уровне проекта устанавливаются в файле _settings.py:_ в словарь `REST_FRAMEWORK` необходимо добавить параметры `DEFAULT_THROTTLE_CLASSES` и `DEFAULT_THROTTLE_RATES`.

Имя `user` предустановлено в классе `UserRateThrottle`, а `anon` — в `AnonRateThrottle`.


```python
REST_FRAMEWORK = {
    'DEFAULT_THROTTLE_CLASSES': [
        'rest_framework.throttling.UserRateThrottle',
        'rest_framework.throttling.AnonRateThrottle',
    ],
    'DEFAULT_THROTTLE_RATES': {
        'user': '10000/day',  # Лимит для UserRateThrottle
        'anon': '1000/day',  # Лимит для AnonRateThrottle
    }
}
```


В параметре `DEFAULT_THROTTLE_CLASSES` мы регистрируем классы пользователей (`UserRateThrottle` и `AnonRateThrottle`), а в `DEFAULT_THROTTLE_RATES` устанавливаем для них ограничения в формате `количество_запросов/период_времени`.

Количество запросов указывается целым числом, период времени указывается как `second`, `minute`, `hour` или `day`.

Готово, общие ограничения для проекта установлены: теперь ни популярность сервиса, ни конкуренты-завистники не выведут его из строя.


## Лимиты на уровне представления

В проекте Kittygram анонимные запросы разрешены только для запроса списка котиков. Эти запросы обрабатываются во вьюсете `CatViewSet`, и лимиты для анонимных запросов можно определить не глобально, а только в этом вьюсете.

```python
REST_FRAMEWORK = {
    'DEFAULT_THROTTLE_CLASSES': [
        'rest_framework.throttling.UserRateThrottle',
        # Не будем подключать класс AnonRateThrottle глобально.
        # Подключим его только в тех view-классах или вьюсетах,
        # где надо установить лимиты для анонимов
    ],
    'DEFAULT_THROTTLE_RATES': {
        # Но сами лимиты установим, и они будут доступны из всего кода проекта
        'user': '10000/day', #  Лимит для UserRateThrottle
        'anon': '1000/day',  #  Лимит для AnonRateThrottle
    }
}
```


В случае с view-классами или вьюсетами в тело класса добавляют атрибут `throttle_classes`:


```python
...

from rest_framework.throttling import AnonRateThrottle

...

class CatViewSet(viewsets.ModelViewSet):
    queryset = Cat.objects.all()
    serializer_class = CatSerializer
    permission_classes = (OwnerOrReadOnly,)
    throttle_classes = (AnonRateThrottle,)  # Подключили класс AnonRateThrottle
```

При такой реализации лимит «1000 запросов в день для анонимных пользователей» сработает точно так же, как если бы он был объявлен в _settings.py_. При превышении лимита будет возвращён код ответа **429 Too Many Requests**, а в теле ответа вернётся сообщение об ограничении доступа и информация о том, через какой период времени можно будет повторить запрос.


![[Pasted image 20250804202134.png]]


Для view-функций есть декоратор `@throttle_classes()`: он принимает на вход классы из `rest_framework.throttling`_._ Подробнее о том, как ещё можно подключать тротлинг-классы, можно посмотреть в [официальной документации](https://www.django-rest-framework.org/api-guide/throttling/#setting-the-throttling-policy).

### Собственный лимит запросов

Лимиты `user` и `anon` встроены в DRF и работают «из коробки». Но можно описывать и применять собственные лимиты (их называют «скоуп», от англ. _scope_ — «пределы, границы»). Для этого в _settings.py_ в настройках DRF нужно **подключить класс** `ScopedRateThrottle`; после этого нужно придумать название для нового скоупа и указать его в `DEFAULT_THROTTLE_RATES`:

```python
REST_FRAMEWORK = {
    ...
    'DEFAULT_THROTTLE_CLASSES': [
        ...
        'rest_framework.throttling.ScopedRateThrottle',
    ],
    'DEFAULT_THROTTLE_RATES': {
        ...
        'user': '10000/day', 
        'anon': '1000/day',  
        # Имена (ключи) для scope придумывает разработчик, 
        # в меру собственной фантазии
        'low_request': '1/minute',
    }
}
```


Теперь новый скоуп можно применять там, где это необходимо. Например, его можно подключить к отдельным view-классам или вьюсетам; скоуп указывается в атрибуте `throttle_scope`:


```python
class CatViewSet(viewsets.ModelViewSet):
    queryset = Cat.objects.all()
    serializer_class = CatSerializer
    permission_classes = (OwnerOrReadOnly,)
    # Для любых пользователей установим кастомный лимит 1 запрос в минуту
    throttle_scope = 'low_request'
```


![[Pasted image 20250804202328.png]]


А запросы к остальным эндпоинтам будут ограничены общими настройками проекта.

### Собственный тротлинг-класс

Работа API Kittygram стабилизировалась. Разбор полётов показал, что проект падал из-за большого количества запросов именно к котикам.

Администраторы сервера настоятельно попросили выделить им два часа в сутки (с трёх до пяти утра) на нагрузочное тестирование запросов к котикам. Они готовы работать ночью, но просят на это время запретить обработку запросов. В остальное время число обрабатываемых запросов должно лимитироваться, как и прежде. Для котиков — один запрос в минуту, для остальных эндпоинтов — в соответствии с настройками на уровне проекта.

Требование довольно своеобразное, готовых решений для этой задачи в DRF нет. Однако есть возможность описать и применить собственный тротлинг-класс. Так и поступим.

Кастомные тротлинг-классы принято описывать и хранить в файле _throttling.py_. Их наследуют от базового класса `BaseThrottle`, и в наследнике описывают метод `allow_request`. Этот метод должен возвращать `True`, если нужно разрешить запрос, и `False` — если запрос следует отклонить.


```python
from rest_framework import throttling

import datetime

class WorkingHoursRateThrottle(throttling.BaseThrottle):

    def allow_request(self, request, view):
        now = datetime.datetime.now().hour
        if now >= 3 and now < 5:
            return False
        return True
```


Готово, осталось только применить новый класс `WorkingHoursRateThrottle` к нужному вьюсету:


```python
from rest_framework.throttling import ScopedRateThrottle

from .throttling import WorkingHoursRateThrottle

...

class CatViewSet(viewsets.ModelViewSet):
    queryset = Cat.objects.all()
    serializer_class = CatSerializer
    permission_classes = (OwnerOrReadOnly,)
    # Если кастомный тротлинг-класс вернёт True - запросы будут обработаны
    # Если он вернёт False - все запросы будут отклонены
    throttle_classes = (WorkingHoursRateThrottle, ScopedRateThrottle)
    # А далее применится лимит low_request
    throttle_scope = 'low_request'
    
```


Задача выполнена: с трёх до пяти утра все запросы к котикам будут отклонены. Потому что ночью спать надо, а не котиков смотреть.