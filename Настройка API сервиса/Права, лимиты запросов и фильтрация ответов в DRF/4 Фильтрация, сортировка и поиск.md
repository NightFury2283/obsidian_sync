[[Фреймворк Django. Работа с проектами]]
[[Python]]
[[API]]
[[Питон Практикум]]

API Kittigram стал безопаснее и удобнее: права доступа настроены, количество запросов лимитировано, выдача разбивается на части. Но неугомонные хозяева котиков продолжают выкатывать новые идеи для улучшения сервиса.

«Как найти всех белых котиков?» — спрашивают одни пользователи. «А как найти на вашем сервисе всех котов по имени Бегемот?» — спрашивают другие. «И год рождения котика тоже важен!» — пишут третьи.

Котиков в самом деле стало очень много, пора добавить гибкости в работе с API: фильтровать список котиков по цвету и году рождения, сортировать результаты и искать объекты по ключевым словам.

Допивайте кофе, доедайте бутерброд, стряхните крошки с клавиатуры — и приступим к работе. Совместим приятное с полезным: порадуем наших пользователей и изучим механизмы фильтрации, поиска и сортировки в Django REST Framework.

Будем есть слона по частям. Сперва — фильтры.


## Фильтрация

Определим задачу: пользователь должен иметь возможность в ответ на GET-запрос получить не всех котиков без разбору, а только рыжих; или только рыжих и только 2017 года рождения.

Для фильтрации котиков по цвету можно дать пользователям возможность делать GET-запросы на эндпоинты такого вида:

```
http://127.0.0.1:8000/cats/<str:color>/ 
```

В Generic-классах и вьюсетах для обработки подобных запросов переопределяют встроенный метод `get_queryset()`, а сам параметр запроса получают через `self.kwargs['<параметр запроса>']`.

Запрос можно обработать так:

```
class CatViewSet(viewsets.ModelViewSet):
    serializer_class = CatSerializer

    def get_queryset(self):
        queryset = Cat.objects.all()
        color = self.kwargs['color']
        # Через ORM отфильтровать объекты модели Cat
        # по значению параметра color, полученного в запросе
        queryset = queryset.filter(color=color)
        return queryset 
```

Код сработает, но при таком подходе придётся значительно увеличить количество эндпоинтов, особенно если применять фильтрацию ко всем полям всех моделей. Например, для одновременной фильтрации по цвету и по году придётся обрабатывать такой эндпоинт:

```
http://127.0.0.1:8000/cats/<str:color>/<int:year>/ 
```

А ведь у модели котика есть и другие поля. Перспективы безрадостны, так дело не пойдёт.

Можно выбрать другой путь: для фильтрации котиков по цвету дать пользователям возможность делать GET-запросы с именованными параметрами:

```
http://localhost:8000/cats/?color=some_color 
```

В этом случае параметр запроса можно получить из свойства `self.request.query_params`. Код обработчика будет практически тем же:

```
class CatViewSet(viewsets.ModelViewSet):
    serializer_class = CatSerializer

    def get_queryset(self):
        queryset = Cat.objects.all()
        # Добыть параметр color из GET-запроса
        color = self.request.query_params.get('color')
        if color is not None:
            #  через ORM отфильтровать объекты модели Cat
            #  по значению параметра color, полученного в запросе
            queryset = queryset.filter(color=color)
        return queryset 
```

Выглядит получше: при таком подходе количество эндпоинтов не изменится. Но для фильтрации по разным полям придётся написать много однотипного кода. Это нам не подходит: мы ценим DRY.

Хорошая новость: эта задача не уникальна, и в DRF уже есть встроенный механизм для её реализации.

Для упрощения работы с фильтрацией и поиском в Django REST Framework доступны фильтрующие бэкенды. **Бэкенд** (от англ. «backend») — это механизм, который можно подключить к проекту, чтобы получить дополнительную функциональность.

### Подключение бэкендов

Необходимый бэкенд [можно подключить](https://www.django-rest-framework.org/api-guide/filtering/#setting-filter-backends) на уровне проекта или на уровне представления. Мы будем работать с бэкендами именно на уровне представлений.

В DRF есть встроенные бэкенды, но есть и внешние, подключаемые. Начнём с подключаемого бэкенда `DjangoFilterBackend`, он идёт в составе библиотеки django-filter.

Установите библиотеку командой `pip install django-filter==23.1` и зарегистрируйте приложение `django_filters` в списке приложений `INSTALLED_APPS`:

```
# kittygram2plus/settings.py

INSTALLED_APPS = [
    ...
    'rest_framework',
    'django_filters', 
    # Обратите внимание: библиотека django-filter, а приложение django_filters
] 
```

Документацию к библиотеке django-filter можно посмотреть [здесь](https://django-filter.readthedocs.io/en/stable/).

### Фильтрация: бэкенд DjangoFilterBackend

Применим фильтрацию к вьюсету `CatViewSet`: по плану требуется фильтровать именно возвращаемый список котиков.

Для подключения фильтрующего бэкенда на уровне представления нужно:

- импортировать необходимый бэкенд,
- в теле класса:
    - в атрибуте `filter_backends` указать фильтрующий бэкенд,
    - в атрибуте `filterset_fields` указать те поля модели, по которым необходима фильтрация.

```
...
from django_filters.rest_framework import DjangoFilterBackend

class CatViewSet(viewsets.ModelViewSet):
    queryset = Cat.objects.all()
    serializer_class = CatSerializer
    permission_classes = (OwnerOrReadOnly,)
    # Указываем фильтрующий бэкенд DjangoFilterBackend
    # Из библиотеки django-filter
    filter_backends = (DjangoFilterBackend,)
    # Временно отключим пагинацию на уровне вьюсета, 
    # так будет удобнее настраивать фильтрацию
    pagination_class = None
    # Фильтровать будем по полям color и birth_year модели Cat
    filterset_fields = ('color', 'birth_year') 
```

Готово. Теперь можно сделать, например, GET-запрос для получения всех чёрных котиков:

```
http://127.0.0.1:8000/cats/?color=Black 
```

Фильтрующий бэкенд передаёт параметры GET-запроса в Django ORM, где и будут формироваться соответствующие запросы на фильтрацию. По умолчанию фильтрация будет осуществляться «по точному совпадению».

В результате из всех котиков, удовлетворяющих полученному GET-запросу, в выдачу попадут только чёрные.

![](https://pictures.s3.yandex.net/resources/S10_13_1700219016.png)

А вот, например, для котиков цвета морской волны, рождённых в 2017 году, GET-запрос мог бы быть таким:

```
http://127.0.0.1:8000/cats/?color=морская%20волна&birth_year=2017 
```

В GET-запросах список параметров начинают со знака вопроса `?`, а отдельные параметры разделяют символом амперсанда `&`.

Последовательности символов, начинающиеся со знака «процент» `%` — это **URL encoding** («кодировка символов для URL»): способ закодировать и передать через URL те спецсимволы, которые по стандарту нельзя включать в URL и в GET-параметры. Например, в _URL encoding_ пробел записывается как `%20` (обычные пробелы в URL запрещены). Таблицу символов и их кодировок можно посмотреть [здесь](https://www.w3schools.com/tags/ref_urlencode.ASP).

## Поиск: бэкенд SearchFilter

Мы научились фильтровать выдачу, теперь разберёмся с поиском. Для этого применим встроенный бэкенд `SearchFilter`. Встроенные фильтрующие бэкенды импортируются из библиотеки `filters`.

Поисковый бэкенд `SearchFilter` подключается к нужному вьюсету через атрибут `filter_backends`, а в атрибуте `search_fields` указываются поля модели, по которым разрешён поиск. Поиск можно вести только по текстовым полям типа `CharField` или `TextField`.

Добавим возможность поиска по имени при GET-запросе к `/cats/`:

```
...

from rest_framework import filters

class CatViewSet(viewsets.ModelViewSet):
    queryset = Cat.objects.all()
    serializer_class = CatSerializer
    permission_classes = (OwnerOrReadOnly,)
    # Добавим в кортеж ещё один бэкенд
    filter_backends = (DjangoFilterBackend, filters.SearchFilter)
    pagination_class = None
    filterset_fields = ('color', 'birth_year')
    search_fields = ('name',) 
```

По умолчанию поиск работает по частичным совпадениям без учёта регистра. Например, при запросе `/cats/?search=mur` в выдачу попадут котики с именем “Murzik” (даже с большой буквы) и “murka”.

> Важно отметить, что при использовании базы данных sqlite поиск нечувствителен к регистру только при запросах на латинице.

Кроме того, можно искать по нескольким совпадениям: в запросе их надо разделить запятыми, без пробелов.

Например, при запросе `http://127.0.0.1:8000/cats/?search=Сн,ок` в выдачу попадут только те котики, где есть одновременно все совпадения, например — «Снежок».

![](https://pictures.s3.yandex.net/resources/S10_14_1700219029.png)

Поиск можно проводить и по содержимому полей связанных моделей. Доступные для поиска поля связанной модели указываются через нотацию с двойным подчёркиванием: `ForeignKey текущей модели__имя поля в связанной модели`.

```
class CatViewSet(viewsets.ModelViewSet):
    queryset = Cat.objects.all()
    serializer_class = CatSerializer
    permission_classes = (OwnerOrReadOnly,)
    filter_backends = (filters.SearchFilter,)
    search_fields = ('achievements__name', 'owner__username')
    pagination_class = None 
```

С такими настройками можно поискать и котиков, у которых в достижениях встречается слово «вазу»:

![](https://pictures.s3.yandex.net/resources/S10_15_1700219044.png)

Поведение поиска можно настроить, добавив специальные символы к названию поля в `search_fields`:

- '^' Начинается с
- '=' полное совпадение
- '@' полнотекстовый поиск ([поддерживается только для PostgreSQL](https://docs.djangoproject.com/en/dev/ref/contrib/postgres/search/))
- '$' регулярное выражение

Например, если имя котика должно начинаться с указанной в параметре `search` строки, то можно сделать вот так:

```
class CatViewSet(viewsets.ModelViewSet):
    queryset = Cat.objects.all()
    serializer_class = CatSerializer
    permission_classes = (OwnerOrReadOnly,)
    filter_backends = (filters.SearchFilter,)
    # Определим, что значение параметра search должно быть началом искомой строки
    search_fields = ('^name',)
    pagination_class = None 
```

Теперь при GET-запросе `http://127.0.0.1:8000/cats/?search=Мур` поиск вернёт котиков, чьи имена начинаются со строки, переданной в параметре `search`:

![](https://pictures.s3.yandex.net/resources/S10_16_1700219059.png)

А вот при GET-запросе на эндпоинт `http://127.0.0.1:8000/cats/?search=ур` уже ничего не найдётся: котиков, имя которых начинается на «ур», у нас в базе данных нет, а «М**ур**зик» не найдётся, потому что `ур` стоит не в начале имени.

## Сортировка выдачи: бэкенд OrderingFilter

Следующая задача — сортировка выдачи. При запросах к API пользователи хотят сортировать список объектов, например упорядочить котиков по имени или по году рождения.

Для сортировки можно подключить встроенный бэкенд `OrderingFilter`; поля для сортировки перечисляются в атрибуте `ordering_fields`.

Добавим и эту возможность к вьюсету `CatViewSet`:

```
...
from rest_framework import filters


class CatViewSet(viewsets.ModelViewSet):
    queryset = Cat.objects.all()
    serializer_class = CatSerializer
    permission_classes = (OwnerOrReadOnly,)
    filter_backends = (DjangoFilterBackend, filters.SearchFilter,
                       filters.OrderingFilter)
    pagination_class = None
    filterset_fields = ('color', 'birth_year')
    search_fields = ('name',)
    ordering_fields = ('name', 'birth_year') 
```

Теперь при GET-запросе вида `/cats/?ordering=name` — применится сортировка выдачи по именам котиков в алфавитном порядке.

![](https://pictures.s3.yandex.net/resources/S10_17_1700219073.png)

Отсортировать список в обратном порядке можно, добавив минус перед именем поля для сортировки: `/cats/?ordering=-name`

![](https://pictures.s3.yandex.net/resources/S10_18_1700219085.png)

Кроме того, результат выдачи можно отсортировать по нескольким полям, например по имени и году рождения `/cats?ordering=name,birth_year`.

Если не указать атрибут `ordering_fields`, то класс фильтра по умолчанию позволит пользователю сортировать по любым доступным для чтения полям сериализатора, указанного в атрибуте `serializer_class`. Эту опцию можно также указать явно, используя специальное значение `'__all__'` атрибута `ordering_fields`.

На уровне вью-класса или вьюсета можно определить сортировку по умолчанию. Если установлен атрибут `ordering`, то переданное ему значение будет использоваться в качестве поля для сортировки по умолчанию при выдаче.

Упорядочим выдачу наших котиков по умолчанию по году рождения.

Теперь код view-класса будет выглядеть так:

```
class CatViewSet(viewsets.ModelViewSet):
    queryset = Cat.objects.all()
    serializer_class = CatSerializer
    permission_classes = (OwnerOrReadOnly,)
    filter_backends = (DjangoFilterBackend, filters.SearchFilter,
                       filters.OrderingFilter)
    pagination_class = None
    filterset_fields = ('color', 'birth_year')
    search_fields = ('name',)
    ordering_fields = ('name', 'birth_year')
    ordering = ('birth_year',) 
```

Теперь в результатах выдачи будет применяться сортировка по умолчанию, дополнительные параметры при запросе не нужны:

![](https://pictures.s3.yandex.net/resources/S10_19_1700219101.png)

Коротко о лимитах, правах, пагинации, фильтрации и поиске — в [шпаргалке](https://code.s3.yandex.net/Python-dev/cheatsheets/046-drf-prava-limity-paginatsija-filtratsija-poisk-/046-drf-prava-limity-paginatsija-filtratsija-poisk-.html).

