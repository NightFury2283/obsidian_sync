[[Фреймворк Django. Работа с проектами]]
[[Python]]
[[API]]
[[Питон Практикум]]

## О теме «**Права, лимиты запросов и фильтрация ответов в DRF»**

В этой теме вы на практике отработаете различные способы детальной настройки собственного API-сервиса. Вы разберётесь, как создавать более сложные REST API на базе Django-проектов.

**Это точно пригодится в жизни?**

Опыт и знания, полученные в этой теме, помогут вам решать задачи, которые встречаются в реальных технических заданиях.

## О теме «**Взаимодействие фронтенда и бэкенда»**

В уроках этой темы вы настроите API для работы с фронтенд-приложением, познакомитесь с библиотекой `drf-yasg` и создадите документацию для API-сервиса, настроите политику единого источника, примените на практике инструменты разработчика в браузере.

Полученные навыки позволят вам подключать к Django-проектам Single Page Applications с использованием API, а также настраивать их взаимодействие. Задача «подружить бэкенд и фронтенд» — типичная задача бэкендера.

## Финальный проект

Спринт закончится большим самостоятельным заданием: вам нужно будет дописать API для Yatube и сделать из него полноценный API-сервис. Так же как и раньше, при работе с финальным заданием вам нужно будет много работать с документацией.

## Определение прав доступа

Определение прав доступа — важная задача при разработке сервиса; если не озаботиться этим вопросом заранее, то возникнет риск, что любой пользователь сможет получить полный доступ ко всем функциям вашего сервиса.

Вы уже ограничивали доступ к API для неаутентифицированных пользователей, придумали и реализовали механизм защиты от несанкционированного редактирования постов и комментариев. Это хороший опыт, он вам точно пригодится.

В последней версии API проекта Kittygram любой аутентифицированный пользователь может удалять и редактировать не только свои, но и чужие записи. Это противоречит как обычной логике, так и техзаданию.

Мало того. Хозяева котиков очень хотят, чтобы об их любимцах узнало как можно больше людей, а доступ на чтение сейчас есть только у аутентифицированных пользователей; это сужает аудиторию. Значит, надо дать доступ на чтение к эндпоинту `/cats/` всем, даже анонимам. Остальные эндпоинты должны быть доступны только зарегистрированным пользователям.

Для продолжения работы клонируйте репозиторий с новой версией проекта: [kittygram2plus](https://github.com/yandex-praktikum/kittygram2plus). Установите виртуальное окружение, выполните миграции, запустите веб-сервер, создайте через API несколько пользователей и получите для них токены, добавьте котиков в базу.


## Разрешения

Для управления правами доступа в DRF есть встроенные классы, они называются **permissions** (по-русски их называют «пермишены», от англ. _permissions_, «разрешения»). Права доступа проверяются при получении запроса, одновременно с аутентификацией: система определяет, достаточно ли у пользователя прав на выполнение запрошенных операций.

Эта проверка выполняется в самом начале обработки запроса.

Настроить права доступа можно на уровне всего проекта или на уровне отдельных классов и функций. Распространённый подход состоит в комбинировании этих настроек: устанавливаются глобальные ограничения на уровне проекта, а при необходимости ограничения ослабляются на уровне классов или функций.

**Разрешения на уровне проекта**

Чтобы определить разрешения на уровне проекта, в словаре настроек `REST_FRAMEWORK` задают параметр `DEFAULT_PERMISSION_CLASSES`. Вы уже делали это, когда подключали в Kittygram аутентификацию по токену:


```python
# settings.py
...

REST_FRAMEWORK = {

    ...

    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticated', 
    ],
}
```


На уровне проекта можно установить один из четырёх вариантов доступа:

- `AllowAny` — всё разрешено, любой пользователь (и даже аноним) может выполнить любой запрос.
- `IsAuthenticated` — только аутентифицированные пользователи имеют доступ к API и могут выполнить любой запрос. Остальным вернётся ответ **"401 Unauthorized"**.
- `IsAuthenticatedOrReadOnly` — то же, что и в предыдущем доступе, но анонимы могут делать запросы на чтение; запросы на создание, удаление или редактирование информации доступны только аутентифицированным пользователям.
- `IsAdminUser` — выполнение запросов запрещено всем, кроме пользователей с правами администратора, тех, для которых свойство `user.is_staff` равно `True`.

Важная особенность ограничения прав на уровне проекта состоит в том, что если ограничение в _settings.py_ не прописано явным образом, то по умолчанию устанавливается доступ `AllowAny`.

Почитайте на досуге [официальную документацию](https://www.django-rest-framework.org/api-guide/permissions/#setting-the-permission-policy) — там много интересных примеров.


После подключения аутентификации по токену в Kittygram установлен вариант доступа `IsAuthenticated`. При таком уровне ограничений попытка анонимно запросить, например, список котиков, закончится неудачей.


Однако часть нашей задачи — предоставить доступ на чтение анонимным пользователям. А вот изменять объекты анонимы не должны, такие запросы надо разрешить только аутентифицированным пользователям — авторам объектов.

Для начала следует изменить настройки _settings.py_: установить уровень доступа `IsAuthenticatedOrReadOnly`:


```python
...

REST_FRAMEWORK = {

    ...

    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticatedOrReadOnly', 
    ],
}
```


Теперь анонимный GET-запрос на получение коллекции котиков будет обработан успешно


А запрос на изменение информации без токена не сработает


**Разрешения на уровне представления**

Анонимный доступ на чтение теперь предоставлен ко всем эндпоинтам, но задача была в ином: анонимный доступ на чтение — только к котикам, а к другим данным, например, к перечню зарегистрированных хозяев — по токену.

Это ограничение лучше организовать так:

- на уровне проекта установить доступ ко всему API только по токену:

```python
REST_FRAMEWORK = {

    ...

    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticated', 
    ],
}
```


- на уровне вьюсета, к которому нужен анонимный доступ, установить разрешение `IsAuthenticatedOrReadOnly`. Для этого нужно импортировать модуль `permissions` из пакета `rest_framework` и добавить атрибут `permission_classes` в тело класса. Дописываем `CatViewSet`:

```python
from rest_framework import permissions

...

class CatViewSet(viewsets.ModelViewSet):
    queryset = Cat.objects.all()
    serializer_class = CatSerializer
    # Устанавливаем разрешение
    permission_classes = (permissions.IsAuthenticatedOrReadOnly,)
```


Теперь анонимным GET-запросом по-прежнему можно получить информацию о котиках


Но информация о пользователях Kittygram для анонимов будет под замком

**Приоритеты разрешений**

У разрешений на уровне проекта приоритет ниже, чем у разрешений на уровне представления. Именно это позволяет локально переопределять права доступа там, где это необходимо.

У разрешений, установленных на одном уровне, тоже есть приоритеты: у более строгих приоритет выше. Если во вьюсете в атрибуте `permission_classes` указать разрешения `IsAuthenticatedOrReadOnly` и `IsAdminUser`, то всем, кроме пользователей с правами админа, будут запрещены любые запросы: у более строгого разрешения — приоритет.


## Создание собственных разрешений

Промежуточный итог: сделать запрос к котикам теперь может любой желающий, запросы о владельцах котов и запросы на изменение или удаление объектов доступны только аутентифицированным пользователям. Отлично, всё по плану.

Но вот незадача: изменить или удалить информацию может любой владелец действующего токена, а не только автор, создавший объект.

Задача в том, чтобы дать разрешение на редактирование или удаление объектов модели Cat только тому пользователю, который создал этот объект; всем прочим пользователям и анонимам информация должна быть доступна только для чтения.

Встроенный пермишен `IsAuthenticatedOrReadOnly` не справится с такой задачей, придётся удалить его из `CatViewSet`. Напишем своё разрешение, в DRF есть такая возможность.


**Методы базового класса BasePermission**

Разрешения в DRF можно разделить на два типа:

- разрешения «на уровне запроса» определяют, разрешён ли **в общем** сделанный запрос: разрешён ли определённый тип запроса, есть ли разрешение для пользователя или для его IP, разрешено ли делать запросы в это время года — могут быть любые условия, касающиеся самого запроса, а не запрашиваемой информации;
- разрешения «на уровне объекта» касаются запрошенных данных: имеет ли право пользователь сделать запрос к определённым данным, является ли пользователь автором этих данных, можно ли к запрошенным данным отправлять запросы определённого типа — для этих разрешений тоже можно установить широкий спектр условий.

В Django REST Framework все классы разрешений наследуются от базового класса `BasePermission`. В нём описаны два метода:

- в методе `has_permission` определяются разрешения на уровне запроса;
- в методе `has_object_permission` устанавливаются разрешения на уровне объекта.

Доступ будет разрешён, если методы вернут `True`.


```python
class BasePermission(metaclass=BasePermissionMetaclass):

    # Определяет права на уровне запроса и пользователя
    def has_permission(self, request, view):
        return True

    # Определяет права на уровне объекта
    def has_object_permission(self, request, view, obj):
        return True
```


И тот, и другой метод обладают информацией о запросе. А `has_object_permission` обладает данными и об объекте запроса.

Чтобы создать собственное разрешение — нужно описать свой класс, расширяющий **BasePermission**, и переопределить один или оба его метода.

Обратите внимание:

- Метод `has_object_permission` никогда не выполняется для представлений, возвращающих коллекции объектов или создающих новый объект модели (поскольку объект ещё не существует).
- Метод `has_object_permission` вызывается только в том случае, если метод `has_permission` вернул `True`. В противном случае ваш кастомный пермишен сразу же вернёт `False`, не вызывая метод `has_object_permission`.
- По умолчанию оба метода возвращают значение `True`. Поэтому если в кастомном пермишене не переопределить эти методы — пользователям будет предоставлен полный доступ.  
    Если же переопределить только один из этих методов — окончательное решение о доступе будет зависеть от результата работы того метода, который был переопределён.

В общем виде алгоритм определения разрешений после получения запроса выглядит так:


![[Pasted image 20250803185345.png]]


Понимание того, как работают эти методы — залог успеха при описании кастомных разрешений.

Теорию преодолели, теперь решим поставленную задачу — напишем кастомный пермишен `OwnerOrReadOnly`, который расширит возможности встроенных пермишенов и разрешит полный доступ к объекту только автору. Разрешения для анонимов пока настраивать не будем: займёмся ими после того, как разберёмся с аутентифицированными пользователями.

В структуре проекта собственные пермишены принято описывать в отдельном файле _permissions.py_.


```python
# cats/permissions.py

from rest_framework import permissions

class OwnerOrReadOnly(permissions.BasePermission):

    def has_permission(self, request, view):
        return (
                request.method in permissions.SAFE_METHODS
                or request.user.is_authenticated
            )

    def has_object_permission(self, request, view, obj):
        return obj.owner == request.user
```


Этот пермишен работает так:

1. Сначала в `has_permission()` проверяется метод запроса и статус пользователя. Если метод запроса безопасный (то есть GET, HEAD или OPTIONS) или если пользователь аутентифицирован (то есть предоставил валидный токен), то метод вернёт `True`. В этом методе доступа к объекту запроса нет, поэтому мы не знаем и никак не можем проверить, является ли пользователь, делающий запрос, автором объекта.
2. Если `has_permission()` вернул `True`, то после получения объекта вызывается метод `has_object_permission()`, в него передаётся запрошенный объект, и теперь в этом методе можно проверить, совпадает ли автор объекта с пользователем из запроса.


Такой пермишен имеет смысл применять только к тем вьюсетам, модели которых содержат поле `owner`; если этого поля нет — пермишен будет бесполезен.

Вьюсет `CatViewSet` работает с моделью **Cat**, значит, при проверке в методе `has_object_permission()` в объект `obj` будет передаваться запрошенный экземпляр модели **Cat**. В этой модели есть поле `owner`, и при проверке будет проведено сравнение пользователя из запроса и содержимого этого поля.

Теперь пермишен `OwnerOrReadOnly` можно подключить к вьюсету `CatViewSet`:


```python
...

from .permissions import OwnerOrReadOnly

class CatViewSet(viewsets.ModelViewSet):
    queryset = Cat.objects.all()
    serializer_class = CatSerializer
    permission_classes = (OwnerOrReadOnly,)
```


Итоговое разрешение на обработку конкретного запроса будет зависеть от того, что за запрос получен:

- запрос для получения списка объектов или создания нового объекта
- или запрос для получения, изменения или удаления конкретного объекта

Задача выполнена, полный доступ к объектам модели **Cat** предоставлен только хозяевам котиков.

Выполните через Postman запросы к различным котикам с токенами разных пользователей. Попробуйте перекрасить котика, отправив запрос с токеном пользователя, который не является его хозяином. Если всё сделано правильно, то такой запрос не будет обработан.


**Различные пермишены для одного вьюсета**

Для одного и того же вьюсета можно применять различные пермишены, например — в зависимости от типа запроса.

Пермишен `OwnerOrReadOnly` настроен так, что при работе именно с вьюсетом при анонимном запросе позволяет получать список котиков, но не позволит получить информацию о конкретном котике.


Так быть не должно. Исправим это.

Опишем ещё один кастомный пермишен в _permissions.py_; назовём его `ReadOnly`:


```python
class ReadOnly(permissions.BasePermission):

    def has_permission(self, request, view):
        return request.method in permissions.SAFE_METHODS
```


Во вьюсете `CatViewSet` определим метод `get_permissions`: зададим условия, при которых должен применяться тот или иной пермишен:


```python
def get_permissions(self):
    # Если в GET-запросе требуется получить информацию об объекте
    if self.action == 'retrieve':
        # Вернём обновлённый перечень используемых пермишенов
        return (ReadOnly(),)
    # Для остальных ситуаций оставим текущий перечень пермишенов без изменений
    return super().get_permissions()
```


Теперь при GET-запросе информации о конкретном котике доступ будет определяться пермишеном `ReadOnly`: запросы будут разрешены всем. При остальных запросах доступ будет определять пермишен `OwnerOrReadOnly`.


Решить задачу с анонимным доступом к объекту можно иначе: нужно немного доработать кастомный пермишен `OwnerOrReadOnly`. Будет здорово, если вы решите задачу и таким способом: этот подход пригодится вам в финальном задании спринта.